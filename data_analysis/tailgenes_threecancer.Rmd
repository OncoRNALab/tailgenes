---
title: "threecancer cohort - tail genes"
author: "Annelien Morlion"
date: '2024-12-24'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
require(ggrepel)
library(here)
library(DESeq2)
require(caret)
require(pROC)

## Define plot style for paper
mytheme = theme_classic(base_size = 7) +
  theme(text = element_text(size=7, colour="black"),
        title = element_text(size=7, colour="black"),
        line = element_line(size=0.5),
        axis.title = element_text(size=7, colour="black"),
        axis.text = element_text(size=7, colour="black"),
        axis.ticks = element_line(size=0.5),
        strip.background = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_blank(),
        legend.position = c(0.8,0.8),
        legend.text = element_text(size=6))
mytheme_discrete_x = mytheme + theme(axis.text.x = element_text(angle=90, hjust=1,vjust=0.5))

color_panel<-c("#e35d6a","#428bca","#5bb75b","#e87810","#23496b","#ffbf00","#cc2028","#039748","pink","gray","darkgray")
cb_color_panel <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

#see https://personal.sron.nl/~pault/
cb_color_panel_highcontrast <- c("#000000","#004488", "#DDAA33", "#BB5566") #+"#FFFFFF" white
cb_color_panel_mediumcontrastpairs <- c('#6699CC', '#004488', '#EECC66', '#994455', '#997700', '#EE99AA') #+"#FFFFFF" white and "#000000" black
cb_color_panel_bright <- c('#4477AA', '#EE6677', '#228833', '#CCBB44', '#66CCEE', '#AA3377', '#BBBBBB')

full_nr <- scales::format_format(big.mark = ",", decimal.mark = ".", scientific = FALSE)

##sample annotation
sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort))
sample_annotation_all <- sample_annotation # keep original table
sample_annotation <- sample_annotation_all %>% filter(Excluded != "x") #filter out low read samples

# Wrapper function for roc (in case one group has no observations: output NA as AUC)
require(pROC)
safe_roc <- function(response, predictor, ...) {
  # Check if there are both cases and controls
  if (length(unique(response)) < 2) {
    warning("ROC calculation skipped: response must have both cases and controls")
    return(list(auc = NA))
  }
  
  args <- list(response = response, predictor = predictor, ...)
  tryCatch({
    result <- do.call(pROC::roc, args)
    return(result)
  }, error = function(e) {
    message("An error occurred in ROC calculation: ", e$message)
    return(list(auc = NA))
  })
}

# Wrapper function for roc.test (in case one group has no observations: output NA as AUC)
safe_roc_test <- function(auc1, auc2) {
  # Check if either AUC is NA
  if (is.null(auc1$auc) || is.null(auc2$auc) || is.na(auc1$auc) || is.na(auc2$auc)) {
    warning("ROC comparison skipped: one of the AUC values is NA")
    return(NA)
  }
  
  tryCatch({
    test_result <- pROC::roc.test(auc1, auc2)
    return(test_result$p.value)
  }, error = function(e) {
    message("An error occurred in ROC comparison: ", e$message)
    return(NA)
  })
}

# Globally suppress messages about grouped output in summarise() or join()
options(dplyr.summarise.inform = FALSE)
options(dplyr.join.inform = FALSE)

```

Normalize data (only needs to be run first time)
```{r, eval=F}
threecancer_counts <- data.table::fread("../input/threecancer_counts.txt", data.table = F, header=T) %>%
  filter(gene_id %in% grep("__",gene_id, invert=T, value=T)) %>%
  pivot_longer(names_to="RNAID",values_to="counts",-"gene_id") %>%
  right_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select("RNAID", "UniqueID"), by="RNAID") #leave out samples with almost no reads

library(biomaRt)
library(DESeq2)
ensembl <- useEnsembl( biomart="ensembl",dataset="hsapiens_gene_ensembl",version=91)
genes_ens <- getBM(attributes=c('ensembl_gene_id','gene_biotype'),mart=ensembl) #get gene biotype

pc_gene_counts <- threecancer_counts %>% left_join(., genes_ens, by=c("gene_id"="ensembl_gene_id")) %>% #add gene biotype
  filter(gene_biotype=="protein_coding") %>% #only keep protein coding genes
  dplyr::select(-c("gene_biotype","RNAID")) %>% #remove gene biotype column, RNAID
  pivot_wider(names_from=UniqueID, values_from=counts) #back to original format: rows=genes, columns=samples

normal_samples <- sample_annotation %>% filter(Cohort=="threecancer") %>% filter(Abbreviation=="CONTROL") %>% pull(UniqueID)
normal_counttable <- dplyr::select(pc_gene_counts, c("gene_id",(normal_samples)))

tumor_samples <- sample_annotation %>% filter(Cohort=="threecancer") %>% filter(Abbreviation!="CONTROL") %>% pull(UniqueID)
tumor_counttable <- dplyr::select(pc_gene_counts, c("gene_id",(tumor_samples))) 
counttable <- full_join(normal_counttable, tumor_counttable, by="gene_id") #join tumor and normal samples
rm(tumor_counttable, normal_counttable)
  
  ## FILTER genes
keep <- (rowSums(dplyr::select(counttable, all_of(normal_samples)) > 9) >= round(length(normal_samples)/2,0)) | #≥50% of normal samples count > 9
  (rowSums(dplyr::select(counttable, all_of(tumor_samples)) > 9) >= round(length(tumor_samples)/2,0)) # OR ≥50% of tumor samples count > 9
#table(keep, useNA="ifany")
#counttable <- counttable[keep, ]
counttable <- column_to_rownames(counttable, "gene_id")

condition <- factor(ifelse(grepl("^CONTROL", colnames(counttable)), "Normal", "Tumor"))
coldata <- data.frame(row.names=colnames(counttable), condition)
dds <- DESeqDataSetFromMatrix(countData=counttable, colData=coldata, design=~condition)

dds <- DESeq(dds)
  
counttable_normalized<-as.data.frame(counts(dds, normalized = TRUE)) %>% rownames_to_column("gene_id")
data.table::fwrite(counttable_normalized, file="../data/threecancer_normcounts_all.txt", quote=F, na="", row.names = F, sep="\t")
rm(counttable_normalized, dds, coldata,condition, counttable,keep,pc_gene_counts, ensembl, genes_ens, normal_samples, tumor_samples)

```


Tail gene analysis: z-score calculation function
```{r}
### log transformation + z scores calculation based on mean and stdev of (log transformed) reference distribution
tail_z_score <- function(samples, Ref_matrix, na.rm=T) {
  #samples: (normalized, non-log transformed) count matrix of samples of interest (genes as rownames, samples as columns)
  #N_matrix: (normalized, non-log transformed) count matrix of reference (genes as rownames, samples as columns) 
  require(tidyverse)
  #logtransform reference
  Ref_logmatrix <- log2(Ref_matrix+1)
  Ref_zscores <- t(Ref_logmatrix) %>% scale(center=T,scale=T) #column scaling and centering (per gene after transformation)
  ##check: mean per gene = 0, sd = 1
  #Ref_zscores %>% data.frame() %>% rownames_to_column("sample") %>% pivot_longer(names_to="gene", values_to = "counts", -"sample") %>% group_by(gene) %>% dplyr::summarise(mean_x=mean(counts), sd_x=sd(counts)) %>% View()
  scaling_factors <- data.frame(mean_Ref = attr(Ref_zscores, "scaled:center"), sd_Ref = attr(Ref_zscores, "scaled:scale")) %>% rownames_to_column("gene_id")
  #mns <- scaling_factors %>% pull(mean_Ref) #mean
  #sds <- scaling_factors %>% pull(sd_Ref) #stdev
  
  #logtransform samples and subtract mean and stdev of reference matrix
  x <- log2(samples+1) %>% data.frame()
  #match returns a vector of the positions of (first) matches of its first argument in its second -> retrieves the corresponding scaling factors for these genes
  mns <- scaling_factors$mean_Ref[match(rownames(x), scaling_factors$gene_id)] 
  sds <- scaling_factors$sd_Ref[match(rownames(x), scaling_factors$gene_id)]
  
  x <- sweep(x,1,mns,"-", check.margin = T) #subtract corresponding reference gene mean from gene counts
  x <- sweep(x,1,sds,"/", check.margin = T) #then divide gene counts by corresponding reference gene stdev
  x
}

```

calculate z-scores for each sample, each time using all control samples as reference except the control sample of interest
```{r}
threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt")

# z-score calculation based on leave one out (LOO) reference in case sample of interest is control sample
z_scores_LOO <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
for (samp in (colnames(threecancer_normcounts)[-1])) {
  #print(samp)
  z_scores_LOO_sample <- tail_z_score(threecancer_normcounts %>% dplyr::select(c("gene_id",all_of(samp))) %>% column_to_rownames("gene_id"),
                                                                threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",colnames(threecancer_normcounts),value =T))) %>% 
                                                  dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                                  column_to_rownames("gene_id"))
  
  z_scores_LOO <- left_join(z_scores_LOO, z_scores_LOO_sample %>% rownames_to_column("gene_id"), by="gene_id")
}

#data.table::fwrite(z_scores_LOO, file = "../data/threecancer_zscores_tail.txt", sep="\t",na="",quote=F, row.names = F)

### save table with tail genes per sample (|z|>3 and ncounts ≥40)
tail_genes <- left_join(z_scores_LOO %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), 
                  threecancer_normcounts %>% #add normalized counts
                   pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                  by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
#summary(tmp)
data.table::fwrite(tail_genes, file="../data/threecancer_tailgenes.txt",sep="\t", row.names = F, quote=F, na="")
rm(tail_genes,z_scores_LOO_sample, samp)

```

Number of tail genes (ncounts≥40, |z|>3) and comparison of normalized counts
```{r}
#z_scores_LOO <- data.table::fread("../data/threecancer_zscores_tail.txt",data.table = F)
tail_genes <- data.table::fread("../data/threecancer_tailgenes.txt",data.table=F)
length(unique(tail_genes$gene_id)) 

mean_Ref <- threecancer_normcounts %>% filter(gene_id %in% unique(tail_genes$gene_id)) %>% 
  pivot_longer(names_to="sample",values_to="ncounts",-"gene_id") %>% 
  mutate(Abbreviation=gsub("_.*","",sample)) %>% filter(Abbreviation=="CONTROL") %>% 
  dplyr::group_by(gene_id) %>% dplyr::summarise(mean_Ref_ncounts=round(mean(ncounts,na.rm=T),2), median_Ref_ncounts=round(median(ncounts,na.rm=T),2)) #%>% 
  #mutate(mean_Ref_ncounts=ifelse(mean_Ref_ncounts<1,round(mean_Ref_ncounts,0),mean_Ref_ncounts), median_Ref_ncounts=ifelse(median_Ref_ncounts<1,round(median_Ref_ncounts,0),median_Ref_ncounts))

ggplot(mean_Ref, aes(x=mean_Ref_ncounts,y=median_Ref_ncounts)) +
  geom_abline(slope=1,intercept=0) +
  geom_point(size=0.5, alpha=0.8, color="darkgoldenrod2") +
  scale_y_log10(labels=full_nr, limits=c(0.5,NA), breaks=c(1, 10,1000,100000)) + scale_x_log10(labels=full_nr, limits=c(0.5,NA), breaks=c(1,10,1000,100000)) +
  mytheme

RefvsSamplecounts <- threecancer_normcounts %>% filter(gene_id %in% unique(tail_genes$gene_id)) %>% 
  pivot_longer(names_to="sample",values_to="ncounts",-"gene_id") %>% 
  mutate(Abbreviation=gsub("_.*","",sample)) %>%
  left_join(mean_Ref) %>% #add average normalized counts in reference
  left_join(z_scores_LOO %>% pivot_longer(names_to="sample",values_to="zscore",-"gene_id")) %>%
  mutate(zscore_stat=ifelse(((zscore>3) & (ncounts>=40)),"z+",ifelse(((zscore<(-3)) & (ncounts>=40)),"z-","no"))) %>% mutate(Abbreviation=ifelse(Abbreviation=="CONTROL","CONTROL",Abbreviation))
  
#all samples vs Reference in one plot (mean)
ggplot() + 
  geom_point(data = RefvsSamplecounts %>% filter(ncounts>0) %>% filter(zscore_stat=="no"),mapping = aes(x=mean_Ref_ncounts,y=ncounts,col=zscore_stat),size=0.1, alpha=0.8) + #add all points with |z|<3 in grey (and smaller)
  geom_point(data = RefvsSamplecounts %>% filter(zscore_stat!="no"),mapping = aes(x=mean_Ref_ncounts, y=ncounts,col=zscore_stat),size=0.2, alpha=0.6) + 
  scale_y_log10(labels=full_nr,limits=c(40,NA)) + #normalized counts in sample of interest at least 40
  scale_x_log10(labels=full_nr, breaks=c(10,1000,100000)) + coord_fixed() +
  geom_abline(slope=1,intercept=0, color="darkgrey",linetype="dashed") +
  mytheme + theme(legend.position="bottom") +
  scale_color_manual(values=c(no="grey88",`z+`="#CC3311",`z-`="#0077BB",`NA`="black")) +
  labs(x="mean normalized counts in reference", y="normalized counts in individual samples")

#split per type (mean)
ggplot() + 
  geom_point(data = RefvsSamplecounts %>% filter(ncounts>0) %>% filter(zscore_stat=="no"),mapping = aes(x=mean_Ref_ncounts,y=ncounts,col=zscore_stat),size=0.1, alpha=0.8) + #add all points with |z|<3 in grey (and smaller)
  geom_point(data = RefvsSamplecounts %>% filter(zscore_stat!="no"),mapping = aes(x=mean_Ref_ncounts, y=ncounts,col=zscore_stat),size=0.2, alpha=0.8) + 
  facet_wrap(~Abbreviation) +
  scale_y_log10(labels=full_nr,limits=c(40,NA)) + 
  scale_x_log10(labels=full_nr, breaks=c(10,1000,100000)) + 
  geom_abline(slope=1,intercept=0, color="darkgrey",linetype="dashed") +
  mytheme + theme(legend.position="bottom") +
  scale_color_manual(values=c(no="grey88",`z+`="#CC3311",`z-`="#0077BB",`NA`="black")) +
  labs(x="mean normalized counts in reference", y="normalized counts in individual samples")

#all samples vs Reference in one plot (median)
ggplot() + 
  geom_point(data = RefvsSamplecounts %>% filter(ncounts>0) %>% filter(zscore_stat=="no"),mapping = aes(x=median_Ref_ncounts,y=ncounts,col=zscore_stat),size=0.1, alpha=0.8) + #add all points with |z|<3 in grey (and smaller)
  geom_point(data = RefvsSamplecounts %>% filter(zscore_stat!="no"),mapping = aes(x=median_Ref_ncounts, y=ncounts,col=zscore_stat),size=0.2, alpha=0.8) + 
  scale_y_log10(labels=full_nr,limits=c(40,NA)) + #normalized counts in sample of interest at least 40
  scale_x_log10(labels=full_nr, breaks=c(10,1000,100000)) + coord_fixed() +
  geom_abline(slope=1,intercept=0, color="darkgrey",linetype="dashed") +
  mytheme + theme(legend.position="bottom") +
  scale_color_manual(values=c(no="grey88",`z+`="#CC3311",`z-`="#0077BB",`NA`="black")) +
  labs(x="median normalized counts in reference", y="normalized counts in individual samples")

#split per type (median)
ggplot() + 
  geom_point(data = RefvsSamplecounts %>% filter(ncounts>0) %>% filter(zscore_stat=="no"),mapping = aes(x=median_Ref_ncounts,y=ncounts,col=zscore_stat),size=0.1, alpha=0.8) + #add all points with |z|<3 in grey (and smaller)
  geom_point(data = RefvsSamplecounts %>% filter(zscore_stat!="no"),mapping = aes(x=median_Ref_ncounts, y=ncounts,col=zscore_stat),size=0.15, alpha=0.5) + 
  facet_wrap(~Abbreviation) +
  scale_y_log10(labels=full_nr,limits=c(40,NA)) + 
  scale_x_log10(labels=full_nr, breaks=c(10,1000,100000)) + 
  geom_abline(slope=1,intercept=0, color="darkgrey",linetype="dashed") +
  mytheme + theme(legend.position="bottom") +
  coord_cartesian(clip = 'on') +
  theme(axis.line=element_line(size=0.3)) +
  scale_color_manual(values=c(no="grey88",`z+`="#CC3311",`z-`="#0077BB",`NA`="black")) +
  labs(x="median normalized counts in reference", y="normalized counts in individual samples")
ggsave("../figures/threecancer_tail_countdistribution.pdf", height=8.8, width=8.8, units="cm",  dpi = 300, useDingbats=F)
ggsave("../figures/threecancer_tail_countdistribution.png", height=8.8, width=8.8, units="cm",  dpi = 600)

rm(mean_Ref,RefvsSamplecounts)

```

Heatmap of tail genes
```{r}
require(pheatmap)
require(RColorBrewer)

#show all genes that are tail gene in at least one sample
tmp2 <- z_scores_LOO %>% filter(gene_id %in% (tail_genes %>% pull(gene_id) %>% unique()))
table(is.na(tmp2))
tmp2[is.na(tmp2)] <- 0 #0/0 = NA

#top off z-scores (max -5 to 5)
tmp2 <- tmp2 %>% column_to_rownames("gene_id")
tmp2[tmp2>5] <- 5
tmp2[tmp2<(-5)] <- -5
tmp2 <- tmp2 %>% rownames_to_column("gene_id")
#table(tmp2==Inf)

paletteLength=40
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd palette lengths
myBreaks <- c(seq(min(tmp2%>% column_to_rownames("gene_id")), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(tmp2%>% column_to_rownames("gene_id"))/paletteLength, max(tmp2%>% column_to_rownames("gene_id")), length.out=floor(paletteLength/2)))

# no clustering of columns, only rows
colnames(tmp2) <- sub("CONTROL","CONTROL",sub("_([0-9])$","_0\\1",gsub("_threecancer","",colnames(tmp2)))) #add trailing 0 for values below 10
tmp2 <- dplyr::select(tmp2, c("gene_id", colnames(tmp2)[-1] %>% sort()))
annot_cols= data.frame(type = gsub("_.*","",colnames(tmp2)), 
        row.names = colnames(tmp2))
annot_cols$type <- factor(annot_cols$type, levels=c("CONTROL","OV","PRAD","UCEC"))

#differential abundance annotation
DAA_genes <- data.table::fread("../data/differentialabundance_threecancer.txt", data.table = F) %>% mutate(DA=ifelse((padj<0.05) & (log2FoldChange>1), "higher", ifelse((padj<0.05) & (log2FoldChange<(-1)), "lower", "no")))  #higher/lower: differentially abundant genes (DA)
annot_rows = data.frame(namesrow=tmp2$gene_id) %>% 
  mutate(differential=ifelse(namesrow %in% (DAA_genes %>% filter(DA=="lower") %>% pull(gene_id)),"lower",
                             ifelse(namesrow %in% (DAA_genes %>% filter(DA=="higher") %>% pull(gene_id)),"higher","no"))) %>% column_to_rownames("namesrow")

annoCol<-list(type=c(CONTROL="#DDAA33",OV="#BB5566",PRAD="#004488",UCEC="#009988"), differential=c(lower="#CCBB44",higher="#AA3377",no="#FFFFFF"))

pheatmap(as.matrix(tmp2 %>% column_to_rownames("gene_id")), 
         color=myColor, breaks=myBreaks, annotation_col = annot_cols,
         annotation_row=annot_rows,border_color=NA,cluster_cols = F,
         annotation_colors = annoCol, annotation_names_col=F, annotation_names_row = F,
         cluster_rows=T,fontsize = 6,fontsize_row = 7, fontsize_col=7,
         show_colnames = F, scale="none", show_rownames = F, clustering_distance_rows = "euclidean",
         treeheight_row = 0, gaps_col = head(as.numeric(cumsum(table(annot_cols$type))),-1), angle_col = 90,
         legend_breaks = c(-4, -2, 0, 2, 4, max(tmp2 %>% column_to_rownames("gene_id"))), 
         legend_labels = c("-4","-2","0","2","4", "z  \n"),#add legend title
         filename = "../figures/threecancer_tail_heatmap.pdf", 
         width=4.76, height=2.40) #inches (width 121mm=4.76in, height 61mm=2.40in)

png(filename="../figures/threecancer_tail_heatmap.png",res = 300, width=12.1, height=6.1, units = "cm")
pheatmap(as.matrix(tmp2 %>% column_to_rownames("gene_id")), 
         color=myColor, breaks=myBreaks, annotation_col = annot_cols,
         annotation_row=annot_rows,border_color=NA,cluster_cols = F,
         annotation_colors = annoCol, annotation_names_col=F, annotation_names_row = F,
         cluster_rows=T,fontsize = 6,fontsize_row = 7, fontsize_col=7,
         show_colnames = F, scale="none", show_rownames = F, clustering_distance_rows = "euclidean",
         treeheight_row = 0, gaps_col = head(as.numeric(cumsum(table(annot_cols$type))),-1), angle_col = 90,
         legend_breaks = c(-4, -2, 0, 2, 4, max(tmp2 %>% column_to_rownames("gene_id"))), 
         legend_labels = c("-4","-2","0","2","4", "z  \n"))#add legend title
dev.off()

rm(tmp2,annoCol,annot_rows,annot_cols,DAA_genes, myBreaks,paletteLength)

```

Recurrence of tail genes within a group
```{r}
nr_samples_total <- sample_annotation %>% filter(Cohort=="threecancer") %>% group_by(Abbreviation) %>% dplyr::summarise(nr_samples_total=n())
#number (and %) of samples per group for which gene is tail gene
tmp2 <- tail_genes %>% mutate(Abbreviation=gsub("_.*","",sample)) %>% group_by(gene_id,Abbreviation) %>% dplyr::summarise(nr_dev_samples=n()) %>% ungroup() %>% left_join(nr_samples_total, by="Abbreviation") %>% mutate(perc_dev_samples=nr_dev_samples/nr_samples_total)
#number of tail genes with same number of samples for which they are tail genes
#make sure all rows are represented (0 if absent)
tmp3 <- tmp2 %>% ungroup() %>% group_by(Abbreviation,nr_dev_samples) %>% dplyr::summarise(nr_genes=n()) %>% full_join(data.frame(Abbreviation=c(rep("CONTROL",max(tmp2$nr_dev_samples)+1), rep("OV",max(tmp2$nr_dev_samples)+1), rep("PRAD",max(tmp2$nr_dev_samples)+1), rep("UCEC",max(tmp2$nr_dev_samples)+1)), nr_dev_samples=rep(seq(0:max(tmp2$nr_dev_samples)),4))) %>%
  mutate(Abbreviation=ifelse(Abbreviation=="CONTROL","CONTROL",Abbreviation))

tmp3[is.na(tmp3)] <- 0

ggplot(tmp3, aes(x=nr_dev_samples, y=nr_genes+0.05,fill=Abbreviation)) +
  geom_bar(stat="identity",position="dodge", width=0.8) +
  scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988")) +
  scale_y_log10(expand=c(0,NA),limits=c(0.9,NA)) +
  mytheme + theme(legend.title = element_blank()) +
  labs(x="shared among x samples", y="number of tail genes")
ggsave("../figures/threecancer_tail_recurrence.pdf", plot=last_plot(), height=6.1, width=5.8, units="cm",  dpi = 300, useDingbats=F)

#make sure 100% is represented (0 if absent)
tmp3 <- tmp2 %>% ungroup() %>% group_by(Abbreviation,perc_dev_samples) %>% dplyr::summarise(nr_genes=n())
tmp3 <- tmp3 %>% 
  full_join(tmp3 %>% group_by(Abbreviation) %>% dplyr::summarise(perc_dev_samples=max(perc_dev_samples)+0.05)) %>% #add a row with the max perc + 5%
  full_join(data.frame(Abbreviation=c("CONTROL","OV","PRAD","UCEC"), perc_dev_samples=c(1,1,1,1))) #add rows for 100%
tmp3$nr_genes[is.na(tmp3$nr_genes)] <- 0 #fill in 0 deviating genes for missing values

ggplot(tmp3, aes(x=perc_dev_samples*100, y=nr_genes,color=Abbreviation)) +
  geom_line() + geom_point(size=0.5) + 
  scale_color_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988")) +
  scale_y_log10() +
  scale_x_continuous() +
  mytheme + theme(legend.title = element_blank()) +
  labs(x="shared among % of samples", y="number of tail genes")
ggsave("../figures/threecancer_tail_recurrence_perc.pdf", plot=last_plot(), height=6.1, width=5.8, units="cm",  dpi = 300, useDingbats=F)


tmp4 <- tmp2 %>% ungroup() %>% mutate(CN=ifelse(Abbreviation=="CONTROL","control","cancer")) %>% 
  group_by(gene_id,CN) %>% dplyr::summarise(nr_dev_samples_allcancer=sum(nr_dev_samples)) %>% #sum nr dev cancer samples
  ungroup() %>% group_by(CN,nr_dev_samples_allcancer) %>% dplyr::summarise(nr_genes=n())
#nr of tail genes not unique for 1 sample
(tmp4 %>% filter(CN=="cancer") %>% filter(nr_dev_samples_allcancer!=1) %>% pull(nr_genes) %>% sum())/(tmp4 %>% filter(CN=="cancer") %>% pull(nr_genes) %>% sum())

### overlap between subtypes
tmp3 <- tail_genes %>% mutate(Abbreviation=gsub("_.*","",sample)) %>% group_by(gene_id,Abbreviation) %>% dplyr::summarise(nr_dev_samples=n()) %>% ungroup() %>% left_join(nr_samples_total, by="Abbreviation") %>% mutate(perc_dev_samples=nr_dev_samples/nr_samples_total)

rm(tmp2,tmp3,tmp4,nr_samples_total,tail_genes)

```

Overlap of tail gene sets
```{r}
tail_genes <- data.table::fread("../data/threecancer_tailgenes.txt",data.table=F) %>%
   mutate(disease=gsub("_.*","",sample)) #deviating genes (Tail)

### overlap plot of tail genes
library(eulerr)
fit <- eulerr::euler(list("OV"=tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), "PRAD"=tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(), "UCEC"= tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique()), 
                       shape="ellipse")
p1<- plot(fit, quantities = TRUE,shape="ellipse", alpha=0.7,edges="white", legend=F,fills=c(OV="#BB5566",PRAD="#004488",UCEC="#009988"), main="overlap tail genes")
print(fit) #no residual errors 
print(p1)

ggsave("../figures/threecancer_tail_overlap.pdf", plot=p1, useDingbats=F,
       width=5.8, height=6.1, units="cm")

#include control group tail genes
fit <- eulerr::euler(list("OV"=tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), "PRAD"=tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(), "UCEC"= tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique(), "CONTROL"=tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique()), 
                       shape="ellipse")
p1<- plot(fit, quantities = TRUE,shape="ellipse", alpha=0.7, #make it a bit more light
          legend=F,fill=c(OV="#BB5566",PRAD="#004488",UCEC="#009988",CONTROL="#DDAA33"), main="overlap tail genes")
print(p1)
print(fit) #residual errors with 4 groups!

#significance of overlap
jaccard <- function(a, b) { #calculate jaccard index
    intersection = length(intersect(a, b))
    union = length(a) + length(b) - intersection
    return (intersection/union)
}

require(GeneOverlap)
#universe?
#how many unique genes have at least 40 normalized counts in 1 sample
universe_threecancer <- length(threecancer_normcounts %>% pivot_longer(names_to="sample",values_to="ncounts",-"gene_id") %>% filter(ncounts>=40) %>% pull(gene_id) %>% unique()) #12249 genes with at least 1 sample with ≥40 normalized counts

#test overlap via GeneOverlap object
#The GeneOverlap class formulates the problem as testing whether two variables are independent, which can be represented as a contingency table, and then uses Fisher’s exact test to find the statistical significance. Here the P-value is zero, which means the overlap is highly significant. The Fisher’s exact test also gives an odds ratio which represents the strength of association. If an odds ratio is equal to or less than 1, there is no association between the two lists. If the odds ratio is much larger than 1, then the association is strong. The class also calculates the Jaccard index which measures the similarity between two lists. The Jaccard index varies between 0 and 1, with 0 meaning there is no similarity between the two and 1 meaning the two are identical. To show some more details, use the print function
### PRAD vs OV set
go.obj.OVPRAD <- newGeneOverlap(tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer) 
go.obj.OVPRAD <- testGeneOverlap(go.obj.OVPRAD)
print(go.obj.OVPRAD)
jaccard(tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique())

### OV vs UCEC set
go.obj.OVUCEC <- newGeneOverlap(tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer) 
go.obj.OVUCEC <- testGeneOverlap(go.obj.OVUCEC)
print(go.obj.OVUCEC)
jaccard(tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique())

### PRAD vs UCEC set
go.obj.PRADUCEC <- newGeneOverlap(tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer) 
go.obj.PRADUCEC <- testGeneOverlap(go.obj.PRADUCEC)
print(go.obj.PRADUCEC)
jaccard(tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique())


#overlap with control tail genes?
go.obj.CTRLOV <- newGeneOverlap(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer) 
go.obj.CTRLOV <- testGeneOverlap(go.obj.CTRLOV)
print(go.obj.CTRLOV)
jaccard(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="OV") %>% pull(gene_id) %>% unique())

go.obj.CTRLPRAD <- newGeneOverlap(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer)
go.obj.CTRLPRAD <- testGeneOverlap(go.obj.CTRLPRAD)
print(go.obj.CTRLPRAD)
jaccard(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="PRAD") %>% pull(gene_id) %>% unique())

go.obj.CTRLUCEC <- newGeneOverlap(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique(),
                         genome.size=universe_threecancer) 
go.obj.CTRLUCEC <- testGeneOverlap(go.obj.CTRLUCEC)
print(go.obj.CTRLUCEC)
jaccard(tail_genes %>% filter(disease=="CONTROL") %>% pull(gene_id) %>% unique(), tail_genes %>% filter(disease=="UCEC") %>% pull(gene_id) %>% unique())

#overlap of unique tail genes across types and differentially abundant mRNAs across types
DAA_threecancer <- data.table::fread("../data/differentialabundance_threecancer.txt", data.table = F) %>% mutate(DA=ifelse((padj<0.05) & (log2FoldChange>1), "higher", ifelse((padj<0.05) & (log2FoldChange<(-1)), "lower", "no"))) #differentially abudant genes (DE)

#nr of tail genes not differentially abundant
table((tail_genes %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(DA!="no") %>% pull(gene_id) %>% unique()))

#nr of tail genes in opposite direction of differential abundance
table((tail_genes %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(DA!="no") %>% pull(gene_id) %>% unique()))
##Per cancer type
table((tail_genes %>% filter((zscores<-3) &(disease=="OV")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="OV") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())) #246 neg. OV tail genes up in OV vs control
table((tail_genes %>% filter((zscores>3) &(disease=="OV")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="OV") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())) #2 pos. OV tail genes up in OV vs control

table((tail_genes %>% filter((zscores<-3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="PRAD") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())) #129 neg. PRAD tail genes up in PRAD vs control
table((tail_genes %>% filter((zscores>3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="PRAD") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())) #0 pos. PRAD tail genes up in PRAD vs control

table((tail_genes %>% filter((zscores<-3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="UCEC") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())) #108 neg. UCEC tail genes up in UCEC vs control
table((tail_genes %>% filter((zscores>3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="UCEC") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())) #0 pos. UCEC tail genes up in UCEC vs control

table((tail_genes %>% filter((zscores<-3) &( (disease=="OV") | (disease=="PRAD"))) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter((cancertype=="OV") | cancertype=="PRAD") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())) #304 neg. OV/PRAD tail genes up in OV/PRAD vs control

# get tail gene names for subsets
PRAD_inv <- unique(c((tail_genes %>% filter((zscores<-3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores<-3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="PRAD") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())], (tail_genes %>% filter((zscores>3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores>3) &(disease=="PRAD")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="PRAD") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())]))

OV_inv <- unique(c((tail_genes %>% filter((zscores<-3) &(disease=="OV")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores<-3) &(disease=="OV")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="OV") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())], (tail_genes %>% filter((zscores>3) &(disease=="OV")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores>3) &(disease=="OV")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="OV") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())]))
UCEC_inv <- unique(c((tail_genes %>% filter((zscores<-3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores<-3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="UCEC") %>% filter(DA=="higher") %>% pull(gene_id) %>% unique())], (tail_genes %>% filter((zscores>3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique())[(tail_genes %>% filter((zscores>3) &(disease=="UCEC")) %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(cancertype=="UCEC") %>% filter(DA=="lower") %>% pull(gene_id) %>% unique())]))


length(unique(c(PRAD_inv,OV_inv,UCEC_inv)))/table((tail_genes %>% pull(gene_id) %>% unique()) %in% (DAA_threecancer %>% filter(DA!="no") %>% pull(gene_id) %>% unique()))[2] #% of cancer sample tail genes that are differential in the respective cancer type have an opposite direction (neg/pos z) than the direction of the differential abundance at group level
```


Test whether there are significantly less tail genes in certain groups
```{r}
tail_genes <- data.table::fread("../data/threecancer_tailgenes.txt",data.table=F) %>%
   mutate(disease=gsub("_.*","",sample)) #deviating genes (Tail) 

tmp2 <- tail_genes %>% group_by(sample) %>% dplyr::summarise(n_dev = n()) %>% mutate(disease=gsub("_.*","",sample))
#make sure no sample is missing
tmp2 <- tmp2 %>% full_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID,"disease"=Abbreviation)), by=c("sample","disease")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev))

library(ggpubr)
#my_comparisons <- list( c("CONTROL", "OV"), c("CONTROL", "PRAD"), c("CONTROL", "UCEC") )
ggplot(tmp2, aes(x=disease,y=n_dev)) +
  geom_boxplot(outlier.size = 0.75,aes(fill=disease)) +
  geom_jitter(height=0, width=0.1,size=0.5,color="grey")+
  mytheme + theme(legend.position="none") +
  scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988"))+
  scale_y_log10(labels=full_nr) +
  labs(y="tail genes",x="") +
  ggpubr::stat_compare_means(method="kruskal",label.y=4, size = 2)   # Add global p-value


rstatix::kruskal_test(data=tmp2, n_dev ~ disease)
rstatix::kruskal_effsize(data=tmp2, n_dev ~ disease)
#rstatix::kruskal_effsize(data=tmp2, n_dev ~ disease,ci=T)
rstatix::wilcox_test(data=tmp2, n_dev ~ disease, p.adjust.method = "BH")
rstatix::wilcox_effsize(data=tmp2, n_dev ~ disease)
#rstatix::wilcox_effsize(data=tmp2, n_dev ~ disease, ci = T)

ggsave("../figures/threecancer_tail_boxplot_logscale.pdf", plot=last_plot(), height=6.1, width=5.8, units="cm",  dpi = 300, useDingbats=F)
kruskal.test(n_dev ~ disease, data = tmp2) # significant difference between Abbreviation types

ggplot(tmp2, aes(x=disease,y=n_dev)) +
  geom_boxplot(outlier.size = 0.75,aes(fill=disease)) +
  geom_jitter(height=0, width=0.1,size=0.5,color="grey")+
  mytheme + theme(legend.position="none") +
  scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988"))+
  #scale_y_log10(labels=full_nr) +
  labs(y="tail genes",x="") +
  ggpubr::stat_compare_means(method="kruskal",label.y=1000, size = 2)   # Add global p-value
  #ggpubr::stat_compare_means(comparisons=my_comparisons, method = "wilcox.test", size = 2) # Pairwise comparison against reference

rstatix::kruskal_test(data=tmp2, n_dev ~ disease)
rstatix::kruskal_effsize(data=tmp2, n_dev ~ disease)
#rstatix::kruskal_effsize(data=tmp2, n_dev ~ disease,ci=T)
rstatix::wilcox_test(data=tmp2, n_dev ~ disease, p.adjust.method = "BH")
rstatix::wilcox_effsize(data=tmp2, n_dev ~ disease)
#rstatix::wilcox_effsize(data=tmp2, n_dev ~ disease, ci = T)

ggsave("../figures/threecancer_tail_boxplot.pdf", plot=last_plot(), height=6.1, width=5.8, units="cm",  dpi = 300, useDingbats=F)
kruskal.test(n_dev ~ disease, data = tmp2) # significant difference between Abbreviation types

```


Internal validation: what if we randomly shuffle sample names (reassign samples to control or cancer group)? 
```{r, warning=F}
#cohort PRAD, UCEC, OV, CONTROL
rm(tail_genes, z_scores_logscale_threecancer,z_scores_logscale_threecancer_normal_notinref,z_scores_LOO)

require(pROC)
require(ggpubr)

set.seed(124)
for (i in 1:20){
#for (i in 1:2){
  print(paste0("Iteration: ",i))
  threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table=F)
  
  ## reorder sample names (and thus cancer/normal type) randomly
  ordersamples_random <- sample(threecancer_normcounts %>% dplyr::select(-gene_id) %>% colnames(.), replace=F)
  #print(grep("CONTROL",ordersamples_random[1:27],value=T))
  print(paste0(length(grep("CONTROL",ordersamples_random[1:27],value=T)), " original control samples in reference"))
  colnames(threecancer_normcounts) <- c("gene_id",ordersamples_random)
  
  #calculate z scores for all genes in every sample based on new reference
  z_scores_LOO_random <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
  for (samp in (colnames(threecancer_normcounts)[-1])) {
    #print(samp)
    z_scores_LOO_random_tmp <- tail_z_score(threecancer_normcounts %>% dplyr::select(c("gene_id",all_of(samp))) %>% column_to_rownames("gene_id") , 
                                                                    threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",colnames(threecancer_normcounts),value =T))) %>% 
                                                                      dplyr::select(-any_of(samp)) %>% #remove sample itself from ref
                                                                      column_to_rownames("gene_id"))
    
    z_scores_LOO_random <- left_join(z_scores_LOO_random, z_scores_LOO_random_tmp %>% rownames_to_column("gene_id"), by="gene_id")
  }

  rm(z_scores_LOO_random_tmp,samp)
  
  tail_genes <- left_join(z_scores_LOO_random %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% 
                          filter(abs(zscores)>3), 
                        threecancer_normcounts %>% #add normalized counts (with same random reshuffled names)
                          pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                        by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
  
  #significant difference between new control group and cancer types?
  tmp2 <- tail_genes %>% group_by(sample) %>% dplyr::summarise(n_dev = n()) %>% mutate(disease=gsub("_.*","",sample))
  #make sure no sample is missing
  tmp2 <- tmp2 %>% full_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID,"disease"=Abbreviation)), by=c("sample","disease")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev))
  
  library(ggpubr)
  my_comparisons <- list( c("CONTROL", "OV"), c("CONTROL", "PRAD"), c("CONTROL", "UCEC") )
  print(ggplot(tmp2, aes(x=disease,y=n_dev)) +
    geom_boxplot(outlier.size = 0.75,aes(fill=disease)) +
    geom_jitter(height=0, width=0.1,size=0.5,color="grey")+
    mytheme + theme(legend.position="none") +
    scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988"))+
    scale_y_log10(labels=full_nr) +
    labs(y="tail genes",x="") +
    ggpubr::stat_compare_means(method="kruskal",label.y=4, size = 3) +  # Add global p-value
    ggpubr::stat_compare_means(comparisons=my_comparisons, method = "wilcox.test", size = 3)) # Pairwise comparison against reference
    #ggpubr::stat_compare_means(label = "p.signif", method = "wilcox.test",p.adjust.method="BH",ref.group = "CONTROL")  # Pairwise comparison against reference
  print(ggpubr::compare_means(n_dev ~ disease, data = tmp2,
                method = "wilcox.test",p.adjust.method = "BH")) #plot contains unadjusted p-values only
  
  print(kruskal.test(n_dev ~ disease, data = tmp2)) # significant difference between any types?
  
}

## get original normalized counts (with correct sample order)
threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table = F)

rm(tail_genes_random,z_scores_LOO_random, tail_genes, tail_genes_FT_ndev)

```

# Biomarker tail gene identification + classification

(10x) 5-fold CV from start + assess performance according to sex
```{r, 5fold CV threecancer, message=F}
sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort)) %>% filter(Cohort=="threecancer") %>% filter(Excluded != "x")

threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt")

# Initialize vector to store AUC values & list to store BTG per repeat and CV
consensus_genes <- list() #for BTG in Fisher's Exact test on entire training set
all_auc_values <- c() #for classification results BTG of 1 FT
all_auc_ci_lower <- c()
all_auc_ci_upper <- c()
all_auc_male_values <- c()
all_auc_female_values <- c()
auc_comparison_sex_pval <- c()

fold_labels <- list()
fold_predictions <- list()

BTGpersample <- data.frame() #dataframe to gather nr of BTG identified in every sample



## Perform repeated 5-fold cross-validation from start to end
set.seed(123)  # for reproducibility
# Number of repeats and folds
num_repeats <- 10 #10 repeats of 5-fold CV  
num_folds <- 5
# Perform repeated cross-validation
for (repeat_x in 1:num_repeats) {
  # Create stratified folds
  sample_annotation$foldID <- seq(1:nrow(sample_annotation))
  sample_annotation$cancer_binary <- ifelse(sample_annotation$Cancer=="no",0,1)
  # make stratified folds of cancer vs control and get the 5 test sets
  folds <- caret::createFolds(factor(sample_annotation$cancer_binary), k = num_folds, list = TRUE, returnTrain = FALSE)
  
  # Perform cross-validation for each fold
  for(i in 1:num_folds) {
    print(paste0("rep",repeat_x,"_",i))
    # Split the data into training and test sets
    test_indices <- folds[[i]]
    testIDs <- sample_annotation$UniqueID[test_indices] #get sample names test set
    trainIDs <- sample_annotation$UniqueID[-test_indices] #get sample names training set
    
    ## z-score calculation
    # based on CONTROLS in training set and not sample itself
    z_scores <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
    ##reference only based on CONTROLS in training except sample itself
    for (samp in (colnames(threecancer_normcounts)[-1])) {
      #print(samp)
      z_scores_sample <- tail_z_score(threecancer_normcounts %>%
                                            dplyr::select(c("gene_id",all_of(samp))) %>%
                                            column_to_rownames("gene_id"),
                                          threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",trainIDs,value =T))) %>% #only training set CONTROL samples
                                            dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                            column_to_rownames("gene_id"))
      
      z_scores <- left_join(z_scores, z_scores_sample %>% rownames_to_column("gene_id"), by="gene_id")
    }
    rm(z_scores_sample)
    
    gene_list <- vector(mode="list")
    
    ### overview tail genes
    tail_genes <- left_join(z_scores %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), 
                            threecancer_normcounts %>% #add normalized counts
                              pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                            by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
    
    z_scores_Tail <- z_scores %>% filter(gene_id %in% unique(tail_genes$gene_id)) 

    #### do classification on BTG as result of 1 FT on entire training set
    ###Do one Fisher test on entire training set (no consensus on LOO) & repeat classification with this BTG set:
    reduced_z_table <- z_scores_Tail %>% dplyr::select(-all_of(testIDs)) #remove test samples
    #Fisher exact test on all samples except sample of interest
    test <- reduced_z_table %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% 
        mutate(disease=gsub("_.*","",sample)) %>% 
        mutate(cancer=ifelse(disease=="CONTROL", "N", "T")) %>% #get tumor/normal annotation
        ungroup() %>% group_by(gene_id,cancer) %>% 
        left_join(threecancer_normcounts %>% #add normalized counts
                    pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"), by=c("gene_id","sample")) %>%
        dplyr::summarise(absz3 = sum( ((abs(zscores)>3) & (ncounts>=40)), na.rm=T), absznot3 = sum( !((abs(zscores)>3) & (ncounts>=40)), na.rm=T))
        #dplyr::summarise(absz3 = sum(abs(zscores)>3, na.rm = T), absznot3 = sum(abs(zscores)<=3, na.rm=T))
      
    test_wide <- test %>% distinct() %>% pivot_wider(names_from=cancer, values_from=c(absz3,absznot3)) %>% column_to_rownames("gene_id")
    df_fisher <- data.frame(p.val=apply(test_wide,1, function(x) fisher.test(matrix(as.numeric(x[1:4]), ncol=2, byrow=T))$p.value))
    consensus_genes[[paste0("rep",repeat_x,"_",i)]]<- df_fisher %>% rownames_to_column("gene_id") %>% filter(p.val<0.05) %>% pull(gene_id) #xxx BTG based on 1 FT
    rm(test_wide, test, df_fisher, reduced_z_table)
    
    ## count nr of BTG consensus genes for each sample
    tail_genes_FT <- tail_genes %>% 
      filter(gene_id %in% consensus_genes[[paste0("rep",repeat_x,"_",i)]]) %>%
      group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
      #make sure all samples are present
      full_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) 
    
    #### Model training and testing (x repeats in y-fold cross-validation!)
    ### train with training, test on testing data
    data <- tail_genes_FT %>% mutate(disease=gsub("_.*","",sample)) %>% mutate(cancer=ifelse(disease=="CONTROL", F, T)) %>% 
      #add ID of stratification as rownames to select rows using these indices
      left_join(sample_annotation %>% dplyr::select(c(sample="UniqueID","foldID"))) #%>%
      #column_to_rownames("foldID")
    
    ## save nr of BTG per sample for each fold and repeat (+indicate test or training status of sample)
      BTGpersample <- rbind(BTGpersample, data %>%
                              mutate(rep=paste0("rep",repeat_x,"_",i), sampletype=ifelse(foldID %in% test_indices, "test","train"), BTGset=length(consensus_genes[[paste0("rep",repeat_x,"_",i)]])))
    
    train_data <- data %>% filter(!(foldID %in% test_indices))
    test_data <- data %>% filter(foldID %in% test_indices)

    # Train a logistic regression model (or any other binomial classification model)
    model <- glm(cancer ~ n_dev, data = train_data, family = binomial)
    
    # Predict probabilities for the test set
    prob_predictions <- predict(model, test_data, type = "response")
    
    # Calculate AUC for the current fold
    roc_curve <- roc(test_data$cancer, prob_predictions, levels=c(F,T), direction = "<")
    # Store predictions and labels for this fold
    fold_predictions[[paste0("rep",repeat_x,"_",i)]] <- prob_predictions
    fold_labels[[paste0("rep",repeat_x,"_",i)]] <- test_data$cancer
  
    #calculate AUC and confidence interval on entire test set
    all_auc_values <- c(all_auc_values, auc(roc_curve))
    all_auc_ci_lower <- c(all_auc_ci_lower, round(ci(roc_curve),4)[1])
    all_auc_ci_upper <- c(all_auc_ci_upper, round(ci(roc_curve),4)[3])
    
    ## Check for impact of confounders
    # Calculate roc data 
    roc_data <- test_data %>% mutate(predictions=prob_predictions, cancer=ifelse(disease=="CONTROL", F, T))
    roc_data <- roc_data %>% left_join(sample_annotation, by=c("sample"="UniqueID"))
    # Stratify by sex
    roc_data_male <- roc_data[roc_data$Sex == "M", ]
    roc_data_female <- roc_data[roc_data$Sex == "F", ]
    # Compute ROC curve and AUC for males
    auc_male <- safe_roc(roc_data_male$cancer, roc_data_male$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
    all_auc_male_values <- c(all_auc_male_values, auc_male$auc)
    # Compute ROC curve and AUC for females
    auc_female <- safe_roc(roc_data_female$cancer, roc_data_female$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
    all_auc_female_values <- c(all_auc_female_values, auc_female$auc)
    # Compare ROC curves
    #will output NA as p-value in case there were no observations for one group in male/female set
    auc_comparison_sex_pval <- c(auc_comparison_sex_pval, safe_roc_test(auc_male, auc_female))
    
    rm(auc_male, auc_female, roc_data, roc_data_male, roc_data_female, model)
    
    
    rm(z_scores, z_scores_Tail, data, train_data, test_data, prob_predictions, tail_genes, tail_genes_FT, gene_list, trainIDs, testIDs, samp, roc_curve)
    
  }
}

### Consensus sets of BTG over all repeats:
## present in 50%
threshold <- ceiling(0.5 * length(consensus_genes))
#count occurence of every gene across elements
all_words <- unlist(consensus_genes) 
word_counts <- table(all_words)
# Filter words that appear in at least 80% of the elements
consensus_50 <- names(word_counts[word_counts >= threshold])
print("50% consensus BTG:")
print(length(consensus_50))
rm(all_words, word_counts, threshold)

## present in any of the sets
consensus_union <- Reduce(union, consensus_genes)
print("union of BTG:")
print(length(consensus_union))

### based on BTG 1 FT on entire set
roc_curves <- list()  # List to store ROC curves for 10 repetitions
# Simulating ROC curves for 10 folds (replace with your actual data)
for (repeat_x in 1:num_repeats){
  for (i in 1:num_folds) {
    # Generate the ROC curve
    roc_curves[[paste0("rep",repeat_x,"_",i)]] <- roc(response = fold_labels[[paste0("rep",repeat_x,"_",i)]], predictor = fold_predictions[[paste0("rep",repeat_x,"_",i)]], levels = c(F, T), direction = "<")
  }
}

### Plotting mean ROC curve as well
# Define specificity points in descending order (from 1 to 0)
specificities <- seq(1, 0, length.out = 100)

# Interpolate sensitivities for each fold at common specificity points
sensitivities <- mapply(function(roc) {
  coords(roc, x = specificities, input = "specificity", ret = "sensitivity", transpose = FALSE)
}, roc = roc_curves, SIMPLIFY = TRUE)

# Convert result to a matrix and ensure each column represents sensitivities for a fold
sensitivities <- matrix(unlist(sensitivities), nrow = length(specificities), byrow = FALSE)
# Calculate the mean sensitivity across folds
mean_sensitivities <- rowMeans(sensitivities, na.rm = TRUE)

# Create a data frame for individual ROC curves
roc_data <- data.frame(
  Specificity = rep(specificities, times = length(roc_curves)),
  Sensitivity = as.vector(sensitivities),
  Fold = rep(1:length(roc_curves), each = length(specificities))
)

# Calculate FPR and arrange
roc_data <- roc_data %>%
  mutate(FPR = 1 - Specificity) %>%
  arrange(FPR)  # Sort by FPR

# Create mean ROC data
mean_roc_data <- data.frame(
  Specificity = specificities,
  Sensitivity = mean_sensitivities
) %>%
  mutate(Fold = "mean", FPR = 1 - Specificity) %>%
  arrange(FPR)  # Sort by FPR

# Create a data frame for (0, 0) point for mean ROC data
mean_roc_data <- rbind(data.frame(Specificity = 1, Sensitivity = 0, Fold = "mean", FPR = 0), mean_roc_data)

# Create a data frame for (0, 0) points, one for each fold
zero_points <- data.frame(Specificity = 1, Sensitivity = 0, Fold = rep(1:length(roc_curves), each = 1), FPR=0)

# Combine the (0, 0) points with the existing ROC data
roc_data <- rbind(zero_points, roc_data)

### Save the roc_data object for later
roc_data_threecancer_5fCV <- rbind(roc_data, mean_roc_data)
rm(roc_curves, roc_data, mean_roc_data, fold_predictions, fold_labels,sensitivities, specificities, zero_points)

BTG_AUC_CV <- data.frame(
    comparison="threecancervsCTRL",
    CV = "start",
    iteration = names(consensus_genes),
    BTG_identification="1FT_zc",
    BTG_set = sapply(consensus_genes, length),
    auc=round(all_auc_values,4),
    ci_lower=all_auc_ci_lower,
    ci_upper=all_auc_ci_upper,
    auc_male = all_auc_male_values,
    auc_female = all_auc_female_values,
    sex_comparison_pval= auc_comparison_sex_pval)
#data.frame(auc=all_auc_values) %>% View()

# Print mean AUC
tmp <- t.test(all_auc_values)
# Extract the mean and confidence interval
mean_auc <- tmp$estimate
lower_ci <- tmp$conf.int[1]
upper_ci <- tmp$conf.int[2]
# Print the results
cat("Mean AUC:", mean_auc, "\n")
cat("95% Confidence Interval:", lower_ci, "-", upper_ci, "\n")
summary(all_auc_values)
rm(tmp)

# Print mean AUC males
tmp <- t.test(all_auc_male_values)
# Extract the mean and confidence interval
mean_auc <- tmp$estimate
lower_ci <- tmp$conf.int[1]
upper_ci <- tmp$conf.int[2]
# Print the results
cat("Mean AUC (males):", mean_auc, "\n")
cat("95% Confidence Interval:", lower_ci, "-", upper_ci, "\n")
summary(all_auc_male_values)
rm(tmp)

# Print mean AUC females
tmp <- t.test(all_auc_female_values)
# Extract the mean and confidence interval
mean_auc <- tmp$estimate
lower_ci <- tmp$conf.int[1]
upper_ci <- tmp$conf.int[2]
# Print the results
cat("Mean AUC (females):", mean_auc, "\n")
cat("95% Confidence Interval:", lower_ci, "-", upper_ci, "\n")
summary(all_auc_female_values)
rm(tmp)

write.table(BTG_AUC_CV,file="../data/tail_genes/BTG_AUC_threecancer_5fCV.txt", row.names = F, , col.names=T, quote=F, na="")
  
write.table(roc_data_threecancer_5fCV, file="../data/tail_genes/ROC_threecancer_5fCV.txt", row.names = F, , col.names=T, quote=F, na="")
  
saveRDS(consensus_genes, file=paste0("../data/tail_genes/BTGidentity_threecancer_5fCV.RData"))

saveRDS(BTGpersample, file="../data/tail_genes/BTGpersample_threecancer_5fCV.RData")

rm(list=c("test_indices", "all_auc_values", "threecancer_normcounts", "sample_annotation", "repeat_x", "mean_auc", "num_folds", "i"))
#rm("BTG_AUC_CV","BTG_AUC_CV_1FT")

#rm(list=ls())

```





Same for individual cancers vs control (only do classification on same sex)

```{r, 5fold CV indiv_cancer, message=F}
sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort)) %>% filter(Cohort=="threecancer") %>% filter(Excluded != "x")

threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt")

roc_data_indivcancer_5fCV <- list()

for (cancer in grep("CONTROL",unique(sample_annotation$Abbreviation),value=T, invert=T)) {
  ## Perform repeated 5-fold cross-validation from start to end
  print(cancer)
  ## select the samples of interest (i.e. from a certain cancer + all controls with matching sex - so male if PRAD, female if UCEC or OV)
  sample_annotation_selected <- sample_annotation %>% filter(Abbreviation %in% c("CONTROL",cancer)) %>% filter(Sex==ifelse(cancer=="PRAD","M","F"))
  
  consensus_genes <- list() #for BTG in Fisher's Exact test on entire training set
  all_auc_values <- c() #for classification results BTG of 1 FT
  all_auc_ci_lower <- c()
  all_auc_ci_upper <- c()
  # Create an empty list to store ROC objects
  fold_predictions <- list()
  fold_labels <- list()
  
  BTGpersample <- data.frame() #dataframe to gather nr of BTG identified in every sample

  set.seed(123)  # for reproducibility
  # Number of repeats and folds
  num_repeats <- 10 #10 repeats of 5-fold CV  
  num_folds <- 5
  
  # Perform repeated cross-validation
  for (repeat_x in 1:num_repeats) {
    # Create stratified folds
    sample_annotation_selected$foldID <- seq(1:nrow(sample_annotation_selected))
    sample_annotation_selected$cancer_binary <- ifelse(sample_annotation_selected$Cancer=="no",0,1)
    # make stratified folds of cancer vs control and get the 5 test sets
    folds <- caret::createFolds(factor(sample_annotation_selected$cancer_binary), k = num_folds, list = TRUE, returnTrain = FALSE)
    
    # Perform cross-validation for each fold
    for(i in 1:num_folds) {
      print(paste0("rep",repeat_x,"_",i))
      # Split the data into training and test sets
      test_indices <- folds[[i]]
      testIDs <- sample_annotation_selected$UniqueID[test_indices] #get sample names test set
      trainIDs <- sample_annotation_selected$UniqueID[-test_indices] #get sample names training set
      
      ## z-score calculation
      # based on CONTROLS in training set and not sample itself
      z_scores <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
      ##reference only based on CONTROLS in training except sample itself
      for (samp in (sample_annotation_selected %>% pull(UniqueID))) {
        #print(samp)
        z_scores_sample <- tail_z_score(threecancer_normcounts %>%
                                          dplyr::select(c("gene_id",all_of(samp))) %>% 
                                          column_to_rownames("gene_id"),
                                        threecancer_normcounts %>% dplyr::select(c("gene_id",all_of(sample_annotation %>% filter(Abbreviation=="CONTROL") %>% filter(!(UniqueID %in% testIDs)) %>% pull(UniqueID)))) %>% #only training set CONTROL samples + controls of other sex
                                          dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                          column_to_rownames("gene_id"))
        
        z_scores <- left_join(z_scores, z_scores_sample %>% rownames_to_column("gene_id"), by="gene_id")
      }
      rm(z_scores_sample)

      gene_list <- vector(mode="list")
      
      ### overview tail genes
      tail_genes <- left_join(z_scores %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), 
                              threecancer_normcounts %>% #add normalized counts
                                pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                              by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
      
      z_scores_Tail <- z_scores %>% filter(gene_id %in% unique(tail_genes$gene_id)) 
      
      ###Do one Fisher test on entire training set (no consensus on LOO) & repeat classification with this BTG set:
      reduced_z_table <- z_scores_Tail %>% dplyr::select(-all_of(testIDs)) #remove test samples
      #Fisher exact test on all samples except sample of interest
      test <- reduced_z_table %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% 
        mutate(disease=gsub("_.*","",sample)) %>% 
        mutate(cancer=ifelse(disease=="CONTROL", "N", "T")) %>% #get tumor/normal annotation
        ungroup() %>% group_by(gene_id,cancer) %>% 
        left_join(threecancer_normcounts %>% #add normalized counts
                    pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"), by=c("gene_id","sample")) %>%
        #dplyr::summarise(absz3 = sum( ((abs(zscores)>3) & (ncounts>=40)), na.rm=T), absznot3 = sum( !((abs(zscores)>3) & (ncounts>=40)), na.rm=T))
        dplyr::summarise(absz3 = sum(abs(zscores)>3, na.rm = T), absznot3 = sum(abs(zscores)<=3, na.rm=T))
      
      test_wide <- test %>% distinct() %>% pivot_wider(names_from=cancer, values_from=c(absz3,absznot3)) %>% column_to_rownames("gene_id")
      df_fisher <- data.frame(p.val=apply(test_wide,1, function(x) fisher.test(matrix(as.numeric(x[1:4]), ncol=2, byrow=T))$p.value))
      consensus_genes[[paste0("rep",repeat_x,"_",i)]]<- df_fisher %>% rownames_to_column("gene_id") %>% filter(p.val<0.05) %>% pull(gene_id) # BTG based on 1 FT
      rm(test_wide, test, df_fisher, reduced_z_table)
      
      
      ## count nr of BTG consensus genes for each sample
      tail_genes_FT <- tail_genes %>% 
        filter(gene_id %in% consensus_genes[[paste0("rep",repeat_x,"_",i)]]) %>%
        group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
        #make sure all samples are present
        full_join(sample_annotation_selected %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) 
      
      #### Model training and testing (x repeats in y-fold cross-validation!)
      ### train with training, test on testing data
      data <- tail_genes_FT %>% mutate(disease=gsub("_.*","",sample)) %>% mutate(cancer=ifelse(disease=="CONTROL", F, T)) %>% 
        #add ID of stratification as rownames to select rows using these indices
        left_join(sample_annotation_selected %>% dplyr::select(c(sample="UniqueID","foldID"))) #%>%
      #column_to_rownames("foldID")
      
      ## save nr of BTG per sample for each fold and repeat (+indicate test or training status of sample)
      BTGpersample <- rbind(BTGpersample, data %>%
                              mutate(rep=paste0("rep",repeat_x,"_",i), sampletype=ifelse(foldID %in% test_indices, "test","train"), BTGset=length(consensus_genes[[paste0("rep",repeat_x,"_",i)]])))
      
      train_data <- data %>% filter(!(foldID %in% test_indices))
      test_data <- data %>% filter(foldID %in% test_indices)
      
      # Train a logistic regression model (or any other binomial classification model)
      model <- glm(cancer ~ n_dev, data = train_data, family = binomial)
      
      # Predict probabilities for the test set
      prob_predictions <- predict(model, test_data, type = "response")
      
      # Calculate AUC for the current fold
      roc_curve <- roc(test_data$cancer, prob_predictions, levels=c(F,T), direction = "<") #control(F)<cancer(T)
      # Store predictions and labels for this fold
      fold_predictions[[paste0("rep",repeat_x,"_",i)]] <- prob_predictions
      fold_labels[[paste0("rep",repeat_x,"_",i)]] <- test_data$cancer
      
      #calculate AUC and confidence interval on entire test set
      all_auc_values <- c(all_auc_values, auc(roc_curve))
      all_auc_ci_lower <- c(all_auc_ci_lower, round(ci(roc_curve),4)[1])
      all_auc_ci_upper <- c(all_auc_ci_upper, round(ci(roc_curve),4)[3])
      
      rm(z_scores, z_scores_Tail, data, train_data, test_data, prob_predictions, tail_genes, tail_genes_FT, gene_list, trainIDs, testIDs, samp, roc_curve)
      
    } #next next fold
  } #next repeat
  
  ### ROC curves per fold
  roc_curves <- list()  # List to store ROC curves for 10 repetitions
  for (repeat_x in 1:num_repeats){
    for (i in 1:num_folds) {
      # Generate the ROC curve
      roc_curves[[paste0("rep",repeat_x,"_",i)]] <- roc(response = fold_labels[[paste0("rep",repeat_x,"_",i)]], predictor = fold_predictions[[paste0("rep",repeat_x,"_",i)]], levels = c(F, T), direction = "<")
    }
  }
  
  ### Mean ROC curve
  # Define specificity points in descending order (from 1 to 0)
  specificities <- seq(1, 0, length.out = 100)
  # Interpolate sensitivities for each fold at common specificity points
  sensitivities <- mapply(function(roc) {
    coords(roc, x = specificities, input = "specificity", ret = "sensitivity", transpose = FALSE)
  }, roc = roc_curves, SIMPLIFY = TRUE)
  
  # Convert result to a matrix and ensure each column represents sensitivities for a fold
  sensitivities <- matrix(unlist(sensitivities), nrow = length(specificities), byrow = FALSE)
  # Calculate the mean sensitivity across folds
  mean_sensitivities <- rowMeans(sensitivities, na.rm = TRUE)
  
  # Create a data frame for individual ROC curves
  roc_data <- data.frame(
    Specificity = rep(specificities, times = length(roc_curves)),
    Sensitivity = as.vector(sensitivities),
    Fold = rep(1:length(roc_curves), each = length(specificities))
  )
  
  # Calculate FPR and arrange
  roc_data <- roc_data %>%
    mutate(FPR = 1 - Specificity) %>%
    arrange(FPR)  # Sort by FPR
  
  # Create mean ROC data
  mean_roc_data <- data.frame(
    Specificity = specificities,
    Sensitivity = mean_sensitivities
  ) %>%
    mutate(Fold = "mean", FPR = 1 - Specificity) %>%
    arrange(FPR)  # Sort by FPR
  
  # Create a data frame for (0, 0) point for mean ROC data
  mean_roc_data <- rbind(data.frame(Specificity = 1, Sensitivity = 0, Fold = "mean", FPR = 0), mean_roc_data)
  
  # Create a data frame for (0, 0) points, one for each fold
  zero_points <- data.frame(Specificity = 1, Sensitivity = 0, Fold = rep(1:length(roc_curves), each = 1), FPR=0)
  
  # Combine the (0, 0) points with the existing ROC data
  roc_data <- rbind(zero_points, roc_data)
  
  ### Save the roc_data object for later
  roc_data_indivcancer_5fCV[[cancer]] <- rbind(roc_data, mean_roc_data)
  rm(roc_curves, roc_data, mean_roc_data, fold_predictions, fold_labels, sensitivities, specificities, zero_points)
  
  BTG_AUC_CV <- data.frame(
    comparison=paste0(cancer,"vsCTRL"),
    CV = "start",
    iteration = names(consensus_genes),
    BTG_identification="1FT_zc",
    BTG_set = sapply(consensus_genes, length),
    auc=round(all_auc_values,4), 
    ci_lower=all_auc_ci_lower,
    ci_upper=all_auc_ci_upper)
  #data.frame(auc=all_auc_values) %>% View()
  
  # Print mean AUC
  tmp <- t.test(all_auc_values)
  # Extract the mean and confidence interval
  mean_auc <- tmp$estimate
  lower_ci <- tmp$conf.int[1]
  upper_ci <- tmp$conf.int[2]
  # Print the results
  cat("Mean AUC:", mean_auc, "\n")
  cat("95% Confidence Interval:", lower_ci, "-", upper_ci, "\n")
  summary(all_auc_values)
  rm(tmp)
  
  write.table(BTG_AUC_CV,file=paste0("../data/tail_genes/BTG_AUC_",cancer,"_5fCV.txt"), row.names = F, , col.names=T, quote=F, na="")
  
  write.table(roc_data_indivcancer_5fCV[[cancer]], file=paste0("../data/tail_genes/ROC_",cancer,"_5fCV.txt"), row.names = F, , col.names=T, quote=F, na="")
  
  saveRDS(consensus_genes, file=paste0("../data/tail_genes/BTGidentity_",cancer,"_5fCV.RData"))
  #consensus_genes <- readRDS(paste0("../data/tail_genes/BTG_identity_",cancer,"_5fCV.RData"))
  saveRDS(BTGpersample, file=paste0("../data/tail_genes/BTGpersample_",cancer,"_5fCV.RData"))
  
  rm(list=c("test_indices", "all_auc_values", "repeat_x", "mean_auc", "num_folds", "consensus_genes_100","i","sample_annotation_selected"))
  
} #next cancertype


#rm("BTG_AUC_CV")
#rm(list=ls())
```



Internal validation: what if we randomly shuffle sample names (label swap: reassign samples to control or cancer group)? + determine consensus biomarker tail genes (leave-one-out Fisher's exact test) of (all) cancer vs control
```{r, warning=F}
require(pROC)
require(ggpubr)

sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% filter(Cohort=="threecancer") %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort)) %>% filter(Excluded != "x")

set.seed(124)
for (swap_x in 1:10){
#for (i in 1:2){
  print(paste0("Label swap: ",swap_x))
  threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table=F) #start from original normalized counts
  
  ## reorder sample names (and thus cancer/normal type) randomly
  ordersamples_random <- sample(threecancer_normcounts %>% dplyr::select(-gene_id) %>% colnames(.), replace=F)
  #print(grep("CONTROL",ordersamples_random[1:12],value=T))
  print(paste0(length(grep("CONTROL",ordersamples_random[1:12],value=T)), " original control samples in reference"))
  colnames(threecancer_normcounts) <- c("gene_id",ordersamples_random)


  # Initialize vector to store AUC values & list to store BTG per repeat and CV
  consensus_genes <- list() #for BTG in Fisher's Exact test on entire training set
  all_auc_values <- c() #for classification results BTG of 1 FT
  all_auc_ci_lower <- c()
  all_auc_ci_upper <- c()
  all_auc_male_values <- c()
  all_auc_female_values <- c()
  auc_comparison_sex_pval <- c()
  
  fold_labels <- list()
  fold_predictions <- list()
  
  BTGpersample <- data.frame() #dataframe to gather nr of BTG identified in every sample
  
  ## Perform repeated 5-fold cross-validation from start to end
  set.seed(124)  # for reproducibility
  # Number of repeats and folds
  num_repeats <- 10 #10 repeats of 5-fold CV  
  num_folds <- 5
  # Perform repeated cross-validation
  for (repeat_x in 1:num_repeats) {
    # Create stratified folds
    sample_annotation$foldID <- seq(1:nrow(sample_annotation))
    sample_annotation$cancer_binary <- ifelse(sample_annotation$Cancer=="no",0,1)
    # make stratified folds of cancer vs control and get the 5 test sets
    folds <- caret::createFolds(factor(sample_annotation$cancer_binary), k = num_folds, list = TRUE, returnTrain = FALSE)
    
    # Perform cross-validation for each fold
    for(i in 1:num_folds) {
      print(paste0("rep",repeat_x,"_",i))
      # Split the data into training and test sets
      test_indices <- folds[[i]]
      testIDs <- sample_annotation$UniqueID[test_indices] #get sample names test set
      trainIDs <- sample_annotation$UniqueID[-test_indices] #get sample names training set
      
      ## z-score calculation
      # based on CONTROLS in training set and not sample itself
      z_scores <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
      ##reference only based on CONTROLS in training except sample itself
      for (samp in (colnames(threecancer_normcounts)[-1])) {
        #print(samp)
        z_scores_sample <- tail_z_score(threecancer_normcounts %>%
                                              dplyr::select(c("gene_id",all_of(samp))) %>%
                                              column_to_rownames("gene_id"),
                                            threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",trainIDs,value =T))) %>% #only training set CONTROL samples
                                              dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                              column_to_rownames("gene_id"))
        
        z_scores <- left_join(z_scores, z_scores_sample %>% rownames_to_column("gene_id"), by="gene_id")
      }
      rm(z_scores_sample)
      
      gene_list <- vector(mode="list")
      
      ### overview tail genes
      tail_genes <- left_join(z_scores %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), 
                              threecancer_normcounts %>% #add normalized counts
                                pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                              by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
      
      z_scores_Tail <- z_scores %>% filter(gene_id %in% unique(tail_genes$gene_id))
      
      #### do classification on BTG as result of 1 FT on entire training set
      ###Do one Fisher test on entire training set (no consensus on LOO) & repeat classification with this BTG set:
      reduced_z_table <- z_scores_Tail %>% dplyr::select(-all_of(testIDs)) #remove test samples
      #Fisher exact test on all samples except sample of interest
      test <- reduced_z_table %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% 
          mutate(disease=gsub("_.*","",sample)) %>% 
          mutate(cancer=ifelse(disease=="CONTROL", "N", "T")) %>% #get tumor/normal annotation
          ungroup() %>% group_by(gene_id,cancer) %>% 
          left_join(threecancer_normcounts %>% #add normalized counts
                      pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"), by=c("gene_id","sample")) %>%
          dplyr::summarise(absz3 = sum( ((abs(zscores)>3) & (ncounts>=40)), na.rm=T), absznot3 = sum( !((abs(zscores)>3) & (ncounts>=40)), na.rm=T))
          #dplyr::summarise(absz3 = sum(abs(zscores)>3, na.rm = T), absznot3 = sum(abs(zscores)<=3, na.rm=T))
        
      test_wide <- test %>% distinct() %>% pivot_wider(names_from=cancer, values_from=c(absz3,absznot3)) %>% column_to_rownames("gene_id")
      df_fisher <- data.frame(p.val=apply(test_wide,1, function(x) fisher.test(matrix(as.numeric(x[1:4]), ncol=2, byrow=T))$p.value))
      consensus_genes[[paste0("rep",repeat_x,"_",i)]]<- df_fisher %>% rownames_to_column("gene_id") %>% filter(p.val<0.05) %>% pull(gene_id) #xxx BTG based on 1 FT
      rm(test_wide, test, df_fisher, reduced_z_table)
      
      ## count nr of BTG consensus genes for each sample
      tail_genes_FT <- tail_genes %>% 
        filter(gene_id %in% consensus_genes[[paste0("rep",repeat_x,"_",i)]]) %>%
        group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
        #make sure all samples are present
        full_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) 
      
      #### Model training and testing (x repeats in y-fold cross-validation!)
      ### train with training, test on testing data
      data <- tail_genes_FT %>% mutate(disease=gsub("_.*","",sample)) %>% mutate(cancer=ifelse(disease=="CONTROL", F, T)) %>% 
        #add ID of stratification as rownames to select rows using these indices
        left_join(sample_annotation %>% dplyr::select(c(sample="UniqueID","foldID"))) #%>%
        #column_to_rownames("foldID")
      
      ## save nr of BTG per sample for each fold and repeat (+indicate test or training status of sample)
      BTGpersample <- rbind(BTGpersample, data %>%
                              mutate(rep=paste0("rep",repeat_x,"_",i), sampletype=ifelse(foldID %in% test_indices, "test","train"), BTGset=length(consensus_genes[[paste0("rep",repeat_x,"_",i)]])))
      
      train_data <- data %>% filter(!(foldID %in% test_indices))
      test_data <- data %>% filter(foldID %in% test_indices)
  
      # Train a logistic regression model (or any other binomial classification model)
      model <- glm(cancer ~ n_dev, data = train_data, family = binomial)
      
      # Predict probabilities for the test set
      prob_predictions <- predict(model, test_data, type = "response")
      
      # Calculate AUC for the current fold
      roc_curve <- roc(test_data$cancer, prob_predictions, levels=c(F,T), direction = "<")
      # Store predictions and labels for this fold
      fold_predictions[[paste0("rep",repeat_x,"_",i)]] <- prob_predictions
      fold_labels[[paste0("rep",repeat_x,"_",i)]] <- test_data$cancer
    
      #calculate AUC and confidence interval on entire test set
      all_auc_values <- c(all_auc_values, auc(roc_curve))
      all_auc_ci_lower <- c(all_auc_ci_lower, round(ci(roc_curve),4)[1])
      all_auc_ci_upper <- c(all_auc_ci_upper, round(ci(roc_curve),4)[3])
      
      ## Check for impact of confounders
      # Calculate roc data 
      roc_data <- test_data %>% mutate(predictions=prob_predictions, cancer=ifelse(disease=="CONTROL", F, T))
      roc_data <- roc_data %>% left_join(sample_annotation, by=c("sample"="UniqueID"))
      # Stratify by sex
      roc_data_male <- roc_data[roc_data$Sex == "M", ]
      roc_data_female <- roc_data[roc_data$Sex == "F", ]
      # Compute ROC curve and AUC for males
      auc_male <- safe_roc(roc_data_male$cancer, roc_data_male$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
      all_auc_male_values <- c(all_auc_male_values, auc_male$auc)
      # Compute ROC curve and AUC for females
      auc_female <- safe_roc(roc_data_female$cancer, roc_data_female$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
      all_auc_female_values <- c(all_auc_female_values, auc_female$auc)
      # Compare ROC curves
      #will output NA as p-value in case there were no observations for one group in male/female set
      auc_comparison_sex_pval <- c(auc_comparison_sex_pval, safe_roc_test(auc_male, auc_female))
      
      rm(auc_male, auc_female, roc_data, roc_data_male, roc_data_female, model)
      
      
      rm(z_scores, z_scores_Tail, data, train_data, test_data, prob_predictions, tail_genes_FT, roc_curve, gene_list, trainIDs, testIDs, samp, roc_curve)
      
    }
  }
  
  BTG_AUC_CV <- data.frame(
      comparison="threecancervsCTRL",
      CV = "start",
      labelswap = swap_x,
      iteration = names(consensus_genes),
      BTG_identification="1FT_zc",
      BTG_set = sapply(consensus_genes, length),
      auc=round(all_auc_values,4),
      ci_lower=all_auc_ci_lower,
      ci_upper=all_auc_ci_upper,
      auc_male = all_auc_male_values,
      auc_female = all_auc_female_values,
      sex_comparison_pval= auc_comparison_sex_pval)
  #data.frame(auc=all_auc_values) %>% View()
  
  write.table(BTG_AUC_CV,file=paste0("../data/tail_genes/labelswap/BTG_AUC_threecancer_5fCV_labelswap-",swap_x,".txt"), row.names = F, , col.names=T, quote=F, na="")
  
  #write.table(roc_data_threecancer_5fCV, file=paste0("../data/tail_genes/labelswap/ROC_threecancer_5fCV_labelswap-",swap_x,".txt"), row.names = F, , col.names=T, quote=F, na="")
  
  saveRDS(consensus_genes, file=paste0("../data/tail_genes/labelswap/BTGidentity_threecancer_5fCV_labelswap-",swap_x,".RData"))
  saveRDS(BTGpersample, file=paste0("../data/tail_genes/labelswap/BTGpersample_threecancer_5fCV_labelswap-",swap_x,".RData"))
  
  rm(BTG_AUC_CV, all_auc_female_values,
     all_auc_male_values, z_scores, z_scores_LOO, 
     consensus_genes,
     all_auc_ci_lower, all_auc_ci_upper, 
     all_auc_values, auc_comparison_sex_pval, 
     tail_genes, tail_genes_consensus, BTGpersample)
}

rm(tail_genes,z_scores_LOO, tail_genes, tail_genes_FT_ndev)
rm(list=c("test_indices", "all_auc_values", "threecancer_normcounts", "sample_annotation", "repeat_x", "mean_auc", "num_folds", "consensus_genes_100","swap_x","i", "all_auc_values"))

## get original normalized counts (with correct sample order)
threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table=F)

```

And for individual cancer-control comparisons
```{r, warning=F}
require(pROC)
require(ggpubr)


set.seed(124)
for (cancer in c("OV","PRAD","UCEC")) {
  print(cancer)
  
  sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% filter(Cohort=="threecancer") %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort)) %>% filter(Excluded != "x")
  
  for (swap_x in 1:10){
  #for (i in 1:2){
    print(paste0("Label swap: ",swap_x))
    threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table=F) #start from original normalized counts
    
    ## select the samples of interest (i.e. from a certain cancer + all controls with matching sex - so male if PRAD, female if UCEC or OV)
    sample_annotation <- sample_annotation %>% filter(Abbreviation %in% c("CONTROL",cancer))
    
    #reduce the threecancer normalized counts set to samples from that cancer type & controls
    threecancer_normcounts <- threecancer_normcounts %>% dplyr::select(c("gene_id",sample_annotation$UniqueID))
  
    ## reorder sample names (and thus cancer/normal type) randomly
    ordersamples_random <- sample(threecancer_normcounts %>% dplyr::select(-gene_id) %>% colnames(.), replace=F)
    #print(grep("CONTROL",ordersamples_random[1:12],value=T))
    #print(paste0(length(grep("CONTROL",ordersamples_random[1:12],value=T)), " original control samples in reference"))
    colnames(threecancer_normcounts) <- c("gene_id",ordersamples_random)
  
  
    # Initialize vector to store AUC values & list to store BTG per repeat and CV
    consensus_genes <- list() #for BTG in Fisher's Exact test on entire training set
    all_auc_values_1FT <- c() #for classification results BTG of 1 FT
    all_auc_ci_lower_1FT <- c()
    all_auc_ci_upper_1FT <- c()
    all_auc_male_values_1FT <- c()
    all_auc_female_values_1FT <- c()
    auc_comparison_sex_pval_1FT <- c()
    
    fold_labels_1FT <- list()
    fold_predictions_1FT <- list()
    
    BTGpersample <- data.frame() #dataframe to gather nr of BTG identified in every sample
    
    ## Perform repeated 5-fold cross-validation from start to end
    set.seed(124)  # for reproducibility
    # Number of repeats and folds
    num_repeats <- 10 #10 repeats of 5-fold CV  
    num_folds <- 5
    # Perform repeated cross-validation
    for (repeat_x in 1:num_repeats) {
      # Create stratified folds
      sample_annotation$foldID <- seq(1:nrow(sample_annotation))
      sample_annotation$cancer_binary <- ifelse(sample_annotation$Cancer=="no",0,1)
      # make stratified folds of cancer vs control and get the 5 test sets
      folds <- caret::createFolds(factor(sample_annotation$cancer_binary), k = num_folds, list = TRUE, returnTrain = FALSE)
      
      # Perform cross-validation for each fold
      for(i in 1:num_folds) {
        print(paste0("rep",repeat_x,"_",i))
        # Split the data into training and test sets
        test_indices <- folds[[i]]
        testIDs <- sample_annotation$UniqueID[test_indices] #get sample names test set
        trainIDs <- sample_annotation$UniqueID[-test_indices] #get sample names training set
        
        ## z-score calculation
        # based on CONTROLS in training set and not sample itself
        z_scores <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
        ##reference only based on CONTROLS in training except sample itself
        for (samp in (colnames(threecancer_normcounts)[-1])) {
          #print(samp)
          z_scores_sample <- tail_z_score(threecancer_normcounts %>%
                                                dplyr::select(c("gene_id",all_of(samp))) %>%
                                                column_to_rownames("gene_id"),
                                              threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",trainIDs,value =T))) %>% #only training set CONTROL samples
                                                dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                                column_to_rownames("gene_id"))
          
          z_scores <- left_join(z_scores, z_scores_sample %>% rownames_to_column("gene_id"), by="gene_id")
        }
        rm(z_scores_sample)
        
        gene_list <- vector(mode="list")
        
        ### overview tail genes
        tail_genes <- left_join(z_scores %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), 
                                threecancer_normcounts %>% #add normalized counts
                                  pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"),
                                by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) 
        
        z_scores_Tail <- z_scores %>% filter(gene_id %in% unique(tail_genes$gene_id))
        
        #### do classification on BTG as result of 1 FT on entire training set
        ###Do one Fisher test on entire training set (no consensus on LOO) & repeat classification with this BTG set:
        reduced_z_table <- z_scores_Tail %>% dplyr::select(-all_of(testIDs)) #remove test samples
        #Fisher exact test on all samples except sample of interest
        test <- reduced_z_table %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% 
            mutate(disease=gsub("_.*","",sample)) %>% 
            mutate(cancer=ifelse(disease=="CONTROL", "N", "T")) %>% #get tumor/normal annotation
            ungroup() %>% group_by(gene_id,cancer) %>% 
            left_join(threecancer_normcounts %>% #add normalized counts
                        pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"), by=c("gene_id","sample")) %>%
            dplyr::summarise(absz3 = sum( ((abs(zscores)>3) & (ncounts>=40)), na.rm=T), absznot3 = sum( !((abs(zscores)>3) & (ncounts>=40)), na.rm=T))
            #dplyr::summarise(absz3 = sum(abs(zscores)>3, na.rm = T), absznot3 = sum(abs(zscores)<=3, na.rm=T))
          
        test_wide <- test %>% distinct() %>% pivot_wider(names_from=cancer, values_from=c(absz3,absznot3)) %>% column_to_rownames("gene_id")
        df_fisher <- data.frame(p.val=apply(test_wide,1, function(x) fisher.test(matrix(as.numeric(x[1:4]), ncol=2, byrow=T))$p.value))
        consensus_genes[[paste0("rep",repeat_x,"_",i)]]<- df_fisher %>% rownames_to_column("gene_id") %>% filter(p.val<0.05) %>% pull(gene_id) #xxx BTG based on 1 FT
        rm(test_wide, test, df_fisher, reduced_z_table)
        
        ## count nr of BTG consensus genes for each sample
        tail_genes_FT <- tail_genes %>% 
          filter(gene_id %in% consensus_genes[[paste0("rep",repeat_x,"_",i)]]) %>%
          group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
          #make sure all samples are present
          full_join(sample_annotation %>% filter(Cohort=="threecancer") %>% dplyr::select(c("sample"=UniqueID)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) 
        
        #### Model training and testing (x repeats in y-fold cross-validation!)
        ### train with training, test on testing data
        data <- tail_genes_FT %>% mutate(disease=gsub("_.*","",sample)) %>% mutate(cancer=ifelse(disease=="CONTROL", F, T)) %>% 
          #add ID of stratification as rownames to select rows using these indices
          left_join(sample_annotation %>% dplyr::select(c(sample="UniqueID","foldID"))) #%>%
          #column_to_rownames("foldID")
        
        ## save nr of BTG per sample for each fold and repeat (+indicate test or training status of sample)
        BTGpersample <- rbind(BTGpersample, data %>%
                                mutate(rep=paste0("rep",repeat_x,"_",i), sampletype=ifelse(foldID %in% test_indices, "test","train"), BTGset=length(consensus_genes[[paste0("rep",repeat_x,"_",i)]])))
        
        train_data <- data %>% filter(!(foldID %in% test_indices))
        test_data <- data %>% filter(foldID %in% test_indices)
    
        # Train a logistic regression model (or any other binomial classification model)
        model <- glm(cancer ~ n_dev, data = train_data, family = binomial)
        
        # Predict probabilities for the test set
        prob_predictions <- predict(model, test_data, type = "response")
        
        # Calculate AUC for the current fold
        roc_curve_1FT <- roc(test_data$cancer, prob_predictions, levels=c(F,T), direction = "<")
        # Store predictions and labels for this fold
        fold_predictions_1FT[[paste0("rep",repeat_x,"_",i)]] <- prob_predictions
        fold_labels_1FT[[paste0("rep",repeat_x,"_",i)]] <- test_data$cancer
      
        #calculate AUC and confidence interval on entire test set
        all_auc_values_1FT <- c(all_auc_values_1FT, auc(roc_curve_1FT))
        all_auc_ci_lower_1FT <- c(all_auc_ci_lower_1FT, round(ci(roc_curve_1FT),4)[1])
        all_auc_ci_upper_1FT <- c(all_auc_ci_upper_1FT, round(ci(roc_curve_1FT),4)[3])
        
        ## Check for impact of confounders
        # Calculate roc data 
        roc_data <- test_data %>% mutate(predictions=prob_predictions, cancer=ifelse(disease=="CONTROL", F, T))
        roc_data <- roc_data %>% left_join(sample_annotation, by=c("sample"="UniqueID"))
        # Stratify by sex
        roc_data_male <- roc_data[roc_data$Sex == "M", ]
        roc_data_female <- roc_data[roc_data$Sex == "F", ]
        # Compute ROC curve and AUC for males
        auc_male <- safe_roc(roc_data_male$cancer, roc_data_male$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
        all_auc_male_values_1FT <- c(all_auc_male_values_1FT, auc_male$auc)
        # Compute ROC curve and AUC for females
        auc_female <- safe_roc(roc_data_female$cancer, roc_data_female$predictions, levels=c(F,T), direction = "<") #will output NA in case one group has no observations
        all_auc_female_values_1FT <- c(all_auc_female_values_1FT, auc_female$auc)
        # Compare ROC curves
        #will output NA as p-value in case there were no observations for one group in male/female set
        auc_comparison_sex_pval_1FT <- c(auc_comparison_sex_pval_1FT, safe_roc_test(auc_male, auc_female))
        
        rm(auc_male, auc_female, roc_data, roc_data_male, roc_data_female, model)
        
        
        rm(z_scores, z_scores_Tail, data, train_data, test_data, prob_predictions, tail_genes_FT, roc_curve, gene_list, trainIDs, testIDs, samp, roc_curve_1FT)
        
      }
    }
    
    ### ROC curves + mean
    roc_curves <- list()  # List to store ROC curves for 10 repetitions
    # Simulating ROC curves for 10 folds (replace with your actual data)
    for (repeat_x in 1:num_repeats){
      for (i in 1:num_folds) {
        # Generate the ROC curve
        roc_curves[[paste0("rep",repeat_x,"_",i)]] <- roc(response = fold_labels_1FT[[paste0("rep",repeat_x,"_",i)]], predictor = fold_predictions_1FT[[paste0("rep",repeat_x,"_",i)]], levels = c(F, T), direction = "<")
      }
    }
    
    ### Plotting mean ROC curve as well
    # Define specificity points in descending order (from 1 to 0)
    specificities <- seq(1, 0, length.out = 100)
    
    # Interpolate sensitivities for each fold at common specificity points
    sensitivities <- mapply(function(roc) {
      coords(roc, x = specificities, input = "specificity", ret = "sensitivity", transpose = FALSE)
    }, roc = roc_curves, SIMPLIFY = TRUE)
    
    # Convert result to a matrix and ensure each column represents sensitivities for a fold
    sensitivities <- matrix(unlist(sensitivities), nrow = length(specificities), byrow = FALSE)
    
    # Calculate the mean sensitivity across folds
    mean_sensitivities <- rowMeans(sensitivities, na.rm = TRUE)
    
    # Create a data frame for individual ROC curves
    roc_data <- data.frame(
      Specificity = rep(specificities, times = length(roc_curves)),
      Sensitivity = as.vector(sensitivities),
      Fold = rep(1:length(roc_curves), each = length(specificities))
    )
    
    # Calculate FPR and arrange
    roc_data <- roc_data %>%
      mutate(FPR = 1 - Specificity) %>%
      arrange(FPR)  # Sort by FPR
    
    # Create mean ROC data
    mean_roc_data <- data.frame(
      Specificity = specificities,
      Sensitivity = mean_sensitivities
    ) %>%
      mutate(Fold = "mean", FPR = 1 - Specificity) %>%
      arrange(FPR)  # Sort by FPR
    
    # Create a data frame for (0, 0) point for mean ROC data
    mean_roc_data <- rbind(data.frame(Specificity = 1, Sensitivity = 0, Fold = "mean", FPR = 0), mean_roc_data)
    
    # Create a data frame for (0, 0) points, one for each fold
    zero_points <- data.frame(Specificity = 1, Sensitivity = 0, Fold = rep(1:length(roc_curves), each = 1), FPR=0)
    
    # Combine the (0, 0) points with the existing ROC data
    roc_data <- rbind(zero_points, roc_data)
    
    ### Save the roc_data object for later
    roc_data_threecancer_5fCV <- rbind(roc_data, mean_roc_data)
    rm(roc_curves, roc_data, mean_roc_data, fold_predictions_1FT, fold_labels_1FT,sensitivities, specificities, zero_points)
    
    BTG_AUC_CV_1FT <- data.frame(
        comparison=paste0(cancer,"vsCTRL"),
        CV = "start",
        labelswap = swap_x,
        iteration = names(consensus_genes),
        BTG_identification="1FT_zc",
        BTG_set = sapply(consensus_genes, length),
        auc=round(all_auc_values_1FT,4),
        ci_lower=all_auc_ci_lower_1FT,
        ci_upper=all_auc_ci_upper_1FT,
        auc_male = all_auc_male_values_1FT,
        auc_female = all_auc_female_values_1FT,
        sex_comparison_pval= auc_comparison_sex_pval_1FT)
    
    write.table(BTG_AUC_CV_1FT,file=paste0("../data/tail_genes/labelswap/BTG_AUC_",cancer,"_5fCV_labelswap-",swap_x,".txt"), row.names = F, , col.names=T, quote=F, na="")
    
    write.table(roc_data_threecancer_5fCV, file=paste0("../data/tail_genes/labelswap/ROC_",cancer,"_5fCV_labelswap-",swap_x,".txt"), row.names = F, , col.names=T, quote=F, na="")
    
    saveRDS(consensus_genes, file=paste0("../data/tail_genes/labelswap/BTGidentity_",cancer,"_5fCV_labelswap-",swap_x,".RData"))
    saveRDS(BTGpersample, file=paste0("../data/tail_genes/labelswap/BTGpersample_",cancer,"_5fCV_labelswap-",swap_x,".RData"))
    
    rm(BTG_AUC_CV_1FT, all_auc_female_values_1FT,
       all_auc_male_values_1FT, z_scores, z_scores_LOO, 
       consensus_80, consensus_genes,
       all_auc_ci_lower_1FT, all_auc_ci_upper_1FT, 
       all_auc_values_1FT, auc_comparison_sex_pval_1FT, 
       tail_genes, tail_genes_consensus, BTGpersample)
  }
}

rm(tail_genes,z_scores_LOO, tail_genes, tail_genes_FT_ndev)
rm(list=c("test_indices", "all_auc_values", "threecancer_normcounts", "sample_annotation", "repeat_x", "mean_auc", "num_folds", "consensus_genes_100","swap_x","i", "all_auc_values_1FT"))

## get original normalized counts (with correct sample order)
threecancer_normcounts <- data.table::fread("../data/threecancer_normcounts_all.txt", data.table=F)

```
Mean ROC curves for 10x 5-fold CV analyses
```{r}
ROC_curves_all <- data.frame()
BTG_AUC_all <- data.frame()

for (cancer in c("OV","PRAD","UCEC","threecancer")){
  print(cancer)
  ROC_curves_all <- plyr::rbind.fill(ROC_curves_all, data.table::fread(file=paste0("../data/tail_genes/ROC_",cancer,"_5fCV.txt"), fill=T, data.table=F) %>% mutate(cohort="threecancer",comparison=paste0(cancer,"vsCTRL"),cancertype=cancer))
  
  BTG_AUC_all <- plyr::rbind.fill(BTG_AUC_all, data.table::fread(file=paste0("../data/tail_genes/BTG_AUC_",cancer,"_5fCV.txt"), fill=TRUE, data.table=F) %>% mutate(cohort="threecancer"))
  
}

# Plot with ggplot2
print(ggplot(ROC_curves_all %>% filter(Fold=="mean") %>% mutate(cancertype=ifelse(cancertype=="threecancer","all",cancertype)),
             aes(x = FPR, y = Sensitivity, color = cancertype)) +
        # Plot individual ROC curves in grey
        geom_line() +
        #facet_wrap(~cancertype) +
        mytheme + coord_fixed(ratio=1) +
        labs(x = 'false positive rate', y = 'true positive rate') +
        theme(legend.position="bottom", legend.title = element_blank()) +
    scale_color_manual(values=c("OV"="#BB5566","PRAD"="#004488","UCEC"="#009988","all"="black")) +
        
        geom_abline(intercept=0, slope=1, linetype="dashed", linewidth=0.5, color="grey"))

ggsave(filename = "../figures/threecancer_biomarkertail_ROC_5fCV.pdf", plot=last_plot(), width=5.8, height=6.1, units="cm")

```

Consensus BTG and boxplots for 10x 5-fold CV
```{r}
sample_annotation <- data.table::fread("../input/SupplTable1_sample_annotation.txt", sep="\t", quote="",header=T, data.table=FALSE) %>% filter(Cohort=="threecancer") %>% mutate(UniqueID = paste0(Abbreviation,"_",ReplicateNr,"_",Cohort)) %>% filter(Excluded != "x")

BTG_genes <- list()
BTG_consensus_50 <- list()
BTG_union <- list()

for (cancer in c("threecancer","OV","PRAD","UCEC")) {
  print(cancer)
  BTG_genes[[cancer]] <- readRDS(file=paste0("../data/tail_genes/BTGidentity_",cancer,"_5fCV.RData"))
  
  ### Consensus sets of BTG over all repeats:
  ## present in 50% of repeat-folds (so for 10x 5-fold CV: threshold = 25)
  threshold <- ceiling(0.5 * length(BTG_genes[[cancer]])) 
  #count occurence of every gene across elements
  all_words <- unlist(BTG_genes[[cancer]]) 
  word_counts <- table(all_words)
  # Filter words that appear in at least 50%
  consensus_50 <- names(word_counts[word_counts >= threshold])
  print(paste("50% consensus BTG:",length(consensus_50)))
  BTG_consensus_50[[cancer]] <- consensus_50
  rm(all_words, word_counts, threshold, consensus_50)
  
  union_BTG <- unique(unlist(BTG_genes[[cancer]]))
  print(paste("union BTG:",length(union_BTG)))
  BTG_union[[cancer]] <- union_BTG
  rm(union_BTG)
  
}

my_comparisons <- list( c("CONTROL", "OV"), c("CONTROL", "PRAD"), c("CONTROL", "UCEC") )

### LOO z-score calculation
z_scores_LOO <- data.frame(gene_id = threecancer_normcounts %>% pull(gene_id))
for (samp in (colnames(threecancer_normcounts)[-1])) {
  #print(samp)
  z_scores_LOO_sample <- tail_z_score(threecancer_normcounts %>% dplyr::select(c("gene_id",all_of(samp))) %>% column_to_rownames("gene_id"),
                                      threecancer_normcounts %>% dplyr::select(c("gene_id",grep("CONTROL",colnames(threecancer_normcounts),value =T))) %>% 
                                        dplyr::select(-any_of(samp)) %>% #remove sample of interest from reference
                                        column_to_rownames("gene_id"))
  
  z_scores_LOO <- left_join(z_scores_LOO, z_scores_LOO_sample %>% rownames_to_column("gene_id"), by="gene_id")
}
rm(z_scores_LOO_sample)

### only keep tail genes per sample (|z|>3 and normalized counts ≥ 40)
tail_genes <- left_join(z_scores_LOO %>% pivot_longer(names_to="sample", values_to="zscores",-"gene_id") %>% filter(!is.na(zscores)) %>% filter(abs(zscores)>3), threecancer_normcounts %>% #add normalized counts             
pivot_longer(names_to="sample",values_to="ncounts",-"gene_id"), by=c("gene_id"="gene_id","sample")) %>% filter(ncounts>=40) %>% mutate(Abbreviation=gsub("_.*","", sample))

## count nr tail genes belonging to consensus BTG set for each sample
BTG_consensus_50_persample <- data.frame()
for (cancer in c("OV","PRAD","UCEC")) {
  BTG_consensus_50_persample <- rbind(BTG_consensus_50_persample, 
                                      tail_genes %>% 
    filter(gene_id %in% BTG_consensus_50[[cancer]]) %>%
    filter(Abbreviation %in% c("CONTROL",cancer)) %>%
    group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
    #make sure all samples are present
    full_join(sample_annotation %>% filter(Abbreviation %in% c("CONTROL",cancer)) %>% dplyr::select(c("sample"=UniqueID, "disease"=Abbreviation)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) %>%
    mutate(comparison=paste0(cancer,"vsCtrl"),disease=factor(disease, levels=c("CONTROL","OV","PRAD","UCEC")), 
           cancer=ifelse(disease=="CONTROL", F, T)) %>% 
      mutate(disease=factor(disease)) %>%
      mutate(disease=relevel(disease,ref="CONTROL")))
}

# Add three-cancer vs control
BTG_consensus_50_persample <- rbind(BTG_consensus_50_persample, 
                                      tail_genes %>% 
    filter(gene_id %in% BTG_consensus_50[["threecancer"]]) %>%
    group_by(sample) %>% dplyr::summarise(n_dev=n()) %>%
    #make sure all samples are present
    full_join(sample_annotation %>% filter(Abbreviation %in% c("CONTROL","OV","PRAD","UCEC")) %>% dplyr::select(c("sample"=UniqueID, "disease"=Abbreviation)), by=c("sample")) %>% mutate(n_dev=ifelse(is.na(n_dev),0,n_dev)) %>%
    mutate(comparison=paste0("allvsCtrl"), 
           disease=factor(ifelse(disease=="CONTROL",disease,"all")),
           cancer=ifelse(disease=="CONTROL", F, T)) %>% 
      mutate(disease=factor(disease)) %>%
      mutate(disease=relevel(disease,ref="CONTROL")))

BTG_consensus_50_persample <- BTG_consensus_50_persample %>% mutate(comparison=factor(comparison, levels=c("allvsCtrl","OVvsCtrl","PRADvsCtrl","UCECvsCtrl")))

ggplot(BTG_consensus_50_persample, aes(x=disease,y=n_dev, fill=disease)) +
  geom_boxplot(outlier.size = 0.6) + scale_y_log10() +
  geom_jitter(size=0.6, height=0,width=0.1,color="grey") +
  mytheme + labs(y="number of biomarker tail genes",x="") +
  theme(legend.position = "none", axis.text.x=element_text(angle=90, hjust=1,vjust=0.5)) +
  scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988", "all"="black")) +
  facet_wrap(~comparison, scales="free_x", nrow=1)

ggsave(filename="../figures/threecancer_biomarkertail_boxplot_5fCVconsensus50_logscale.pdf", plot=last_plot(), width=5.8, height=6.1, units="cm")

ggplot(BTG_consensus_50_persample, aes(x=disease,y=n_dev, fill=disease)) +
  geom_boxplot(outlier.size = 0.6) +
  geom_jitter(size=0.6, height=0,width=0.1,color="grey") +
  mytheme + labs(y="number of biomarker tail genes",x="") +
  theme(legend.position = "none") +
  scale_fill_manual(values=c("CONTROL"="#DDAA33","OV"="#BB5566","PRAD"="#004488","UCEC"="#009988","all"="black")) +
  facet_wrap(~comparison, scales="free_x",nrow=1)

ggsave(filename="../figures/threecancer_biomarkertail_boxplot_5fCVconsensus50.pdf", plot=last_plot(), width=5.8, height=6.1, units="cm")


rstatix::kruskal_test(data=BTG_consensus_50_persample, n_dev ~ disease)
rstatix::kruskal_effsize(data=BTG_consensus_50_persample, n_dev ~ disease)
#rstatix::kruskal_effsize(data=data, n_dev ~ disease,ci=T)
data_tmp <- BTG_consensus_50_persample %>% mutate(disease=paste(disease)) #mutate disease column to string (otherwise error when performing wilcoxon tests because factors are missing)
rstatix::wilcox_test(data=data_tmp %>% filter(comparison=="allvsCtrl"), n_dev ~ disease)
rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="allvsCtrl"), n_dev ~ disease)
#rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="allvsCtrl"), n_dev ~ disease,ci=T)
rstatix::wilcox_test(data=data_tmp %>% filter(comparison=="OVvsCtrl"), n_dev ~ disease)
rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="OVvsCtrl"), n_dev ~ disease)
#rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="OVvsCtrl"), n_dev ~ disease,ci=T)
rstatix::wilcox_test(data=data_tmp %>% filter(comparison=="PRADvsCtrl"), n_dev ~ disease)
rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="PRADvsCtrl"), n_dev ~ disease)
#rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="PRADvsCtrl"), n_dev ~ disease,ci=T)
rstatix::wilcox_test(data=data_tmp %>% filter(comparison=="UCECvsCtrl"), n_dev ~ disease) 
rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="UCECvsCtrl"), n_dev ~ disease)
#rstatix::wilcox_effsize(data=data_tmp %>% filter(comparison=="UCECvsCtrl"), n_dev ~ disease,ci=T)

my_comparisons=list(c("Co","Ca"), c("Co","OV"), c("Co","PRAD"),c("Co","UCEC"))

### count the nr of BTG in each fold/repeat
count_words <- function(sublist) {
  sum(sapply(sublist, function(sentence) str_count(sentence, "\\S+")))
}

# summary threecancer
sapply(BTG_genes[["threecancer"]], count_words) %>% unlist() %>% summary()

# summary OV
sapply(BTG_genes[["OV"]], count_words) %>% unlist() %>% summary()

# summary PRAD
sapply(BTG_genes[["PRAD"]], count_words) %>% unlist() %>% summary()

# summary UCEC
sapply(BTG_genes[["UCEC"]], count_words) %>% unlist() %>% summary()

```

Overlap of consensus BTG:
```{r}
DAA_threecancer <- data.table::fread("../data/differentialabundance_threecancer.txt", data.table = F) %>% mutate(DA=ifelse((padj<0.05) & (log2FoldChange>1), "higher", ifelse((padj<0.05) & (log2FoldChange<(-1)), "lower", "no"))) #differentially abudant genes (DE)

### overlap plot of biomarker tail genes
library(eulerr)
fit <- eulerr::euler(list("OV"=BTG_consensus_50[["OV"]], "PRAD"=BTG_consensus_50[["PRAD"]], "UCEC"= BTG_consensus_50[["UCEC"]]), 
                       shape="ellipse")
p1<- plot(fit, quantities = TRUE,shape="ellipse", alpha=0.7, edges="white", #make it a bit more light
          legend=F,fill=c(OV="#BB5566",PRAD="#004488",UCEC="#009988"), main="overlap recurrent tail genes")
print(fit) #no residual errors 
print(p1)
ggsave("../figures/threecancer_BTG_consensus50_overlap.pdf", plot=p1, useDingbats=F, width=5.8, height=6.1, units="cm")

jaccard <- function(a, b) { #calculate jaccard index
    intersection = length(intersect(a, b))
    union = length(a) + length(b) - intersection
    return (intersection/union)
}


require(GeneOverlap)
#test overlap via GeneOverlap object
go.obj.OVPRAD <- newGeneOverlap(BTG_consensus_50[["OV"]],
                         BTG_consensus_50[["PRAD"]],
                         genome.size=length(unique(tail_genes$gene_id))) #all (3312) tail genes
go.obj.OVPRAD <- testGeneOverlap(go.obj.OVPRAD)
print(go.obj.OVPRAD)
jaccard(BTG_consensus_50[["OV"]], BTG_consensus_50[["PRAD"]])

go.obj.OVUCEC <- newGeneOverlap(BTG_consensus_50[["OV"]],
                         BTG_consensus_50[["UCEC"]],
                         genome.size=length(unique(tail_genes$gene_id))) #all (3312) tail genes
go.obj.OVUCEC <- testGeneOverlap(go.obj.OVUCEC)
print(go.obj.OVUCEC)
jaccard(BTG_consensus_50[["OV"]], BTG_consensus_50[["UCEC"]])

go.obj.PRADUCEC <- newGeneOverlap(BTG_consensus_50[["PRAD"]],
                         BTG_consensus_50[["UCEC"]],
                         genome.size=length(unique(tail_genes$gene_id))) #all (3312) tail genes
go.obj.PRADUCEC <- testGeneOverlap(go.obj.PRADUCEC)
print(go.obj.PRADUCEC)
jaccard(BTG_consensus_50[["PRAD"]], BTG_consensus_50[["UCEC"]])

#overlap of unique biomarker tail genes in different types and differentially abundant mRNAs across types
table((c(BTG_consensus_50[["OV"]],BTG_consensus_50[["PRAD"]],BTG_consensus_50[["UCEC"]]) %>% unique()) %in% (DAA_threecancer %>% filter(DA!="no") %>% pull(gene_id) %>% unique()))

#overlap of unique biomarker tail genes across types (all cancer) and differentially abundant mRNAs across types
table((c(BTG_consensus_50[["all"]]) %>% unique()) %in% (DAA_threecancer %>% filter(DA!="no") %>% pull(gene_id) %>% unique())) #46% of 108 are also differentially abundant in a certain type vs control
```


Overview table of 50% consensus BTG for the different comparisons
```{r}
require(biomaRt)
ensembl <- useEnsembl(biomart="ensembl",dataset="hsapiens_gene_ensembl",version=91)
genes_ens_full <- getBM(attributes=c('ensembl_gene_id','external_gene_name','description'), mart =ensembl)

biomarker_overview = data.frame(ensembl_gene_id=c(BTG_consensus_50[["threecancer"]], BTG_consensus_50[["OV"]], BTG_consensus_50[["PRAD"]], BTG_consensus_50[["UCEC"]]), biomarkerset=c(rep("all vs CONTROL",length(BTG_consensus_50[["threecancer"]])), rep("OV vs CONTROL",length(BTG_consensus_50[["OV"]])), rep("PRAD vs CONTROL",length(BTG_consensus_50[["PRAD"]])),rep("UCEC vs CONTROL",length(BTG_consensus_50[["UCEC"]])))) %>% left_join(genes_ens_full)

data.table::fwrite(biomarker_overview %>% dplyr::select(c("set"="biomarkerset","ensembl_gene"="ensembl_gene_id","gene_name"="external_gene_name")),file = "../data/threecancer_biomarkertail_list_5foldCV_consensus50.txt", sep="\t",quote=F,row.names=F)
```